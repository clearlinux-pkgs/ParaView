From 4e23c7b5e1b854e706ca586651aca74aafa8a167 Mon Sep 17 00:00:00 2001
From: cgns Upstream <kwrobot@kitware.com>
Date: Wed, 1 Apr 2020 09:48:38 -0400
Subject: [PATCH] cgns 2020-04-01 (9c5e1e9b)

Code extracted from:

    https://gitlab.kitware.com/third-party/cgns.git

at commit 9c5e1e9b15b52e53265c3aadce9c803b94f75f3d (for/paraview-20200401-4.1.1).
---
 CMakeLists.txt          |   44 +-
 README.md               |   92 +--
 src/CMakeLists.txt      |   45 +-
 src/adf/ADF.h           |    5 +-
 src/adf/ADF_interface.c |   41 +-
 src/adf/ADF_internals.c |   80 +-
 src/adfh/ADFH.c         |  265 +++---
 src/adfh/ADFH.h         |    6 +-
 src/cgns_header.h       |   23 +-
 src/cgns_internals.c    |  244 ++++--
 src/cgns_io.c           |  220 ++---
 src/cgns_io.h           |   27 +-
 src/cgnsconfig.h.in     |    2 -
 src/cgnslib.c           | 1687 +++++++++++++++++++++++++++++----------
 src/cgnslib.h           |   51 +-
 src/cgnstypes.h.in      |    8 +-
 src/pcgnslib.c          |   34 +-
 src/vtk_cgns_mangle.h   |    1 +
 18 files changed, 1957 insertions(+), 918 deletions(-)

diff --git a/ThirdParty/cgns/vtkcgns/CMakeLists.txt b/ThirdParty/cgns/vtkcgnsCMakeLists.txt
index e7d8edefa8c..bed400f6ee3 100644
--- a/ThirdParty/cgns/vtkcgns/CMakeLists.txt
+++ b/ThirdParty/cgns/vtkcgns/CMakeLists.txt
@@ -2,9 +2,6 @@ if (FALSE) # XXX(kitware): ParaView handles versions.
 cmake_minimum_required(VERSION 2.8)
 if(COMMAND cmake_policy)
   cmake_policy(SET CMP0003 NEW)
-  if (${CMAKE_MAJOR_VERSION} GREATER 2 OR ${CMAKE_MINOR_VERSION} GREATER 7)
-    cmake_policy(SET CMP0015 OLD)
-  endif (${CMAKE_MAJOR_VERSION} GREATER 2 OR ${CMAKE_MINOR_VERSION} GREATER 7)
 endif(COMMAND cmake_policy)
 
 set(CMAKE_BUILD_TYPE "Release" CACHE STRING
@@ -15,7 +12,7 @@ endif (${CMAKE_MAJOR_VERSION} GREATER 2 OR ${CMAKE_MINOR_VERSION} GREATER 7)
 endif ()
 
 project("cgns" C)
-set(CGNS_VERSION "4.0")
+set(CGNS_VERSION "4.1")
 
 if (FALSE) # XXX(kitware): ParaView doesn't need CPack here.
 # Allow for building a package
@@ -396,25 +393,29 @@ endif ()
 ####################
 
 if (FALSE) # XXX(kitware): ParaView handles rpaths.
-# use, i.e. don't skip the full RPATH for the build tree
-set(CMAKE_SKIP_BUILD_RPATH  FALSE)
-
-# when building, don't use the install RPATH already
-# (but later on when installing)
-set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
-
-# the RPATH to be used when installing
-set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")
-
-# add the automatically determined parts of the RPATH
-# which point to directories outside the build tree to the install RPATH
-set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
+if (CGNS_BUILD_SHARED)
+  # use, i.e. don't skip the full RPATH for the build tree
+  set(CMAKE_SKIP_BUILD_RPATH  FALSE)
+
+  # when building, don't use the install RPATH already
+  # (but later on when installing)
+  set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
+
+  # the RPATH to be used when installing
+  set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")
+
+  # add the automatically determined parts of the RPATH
+  # which point to directories outside the build tree to the install RPATH
+  set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
+
+  IF (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
+     set(CMAKE_MACOSX_RPATH TRUE)
+  ENDIF()
+else(CGNS_BUILD_SHARED)
+set(CMAKE_SKIP_RPATH TRUE)
+endif(CGNS_BUILD_SHARED)
 endif ()
 
-IF (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
-   set(CMAKE_MACOSX_RPATH TRUE)
-ENDIF()
-
 #-----------------------------------------------------------------------------
 # Dashboard and Testing Settings
 #-----------------------------------------------------------------------------
@@ -441,4 +442,3 @@ endif (CGNS_BUILD_TESTING)
 
 # Include the src directory
 add_subdirectory(src)
-
diff --git a/README.md b/README.md
index 4022ea02042..afd6b23e09f 100644
--- a/ThirdParty/cgns/vtkcgns/README.md
+++ b/ThirdParty/cgns/vtkcgns/README.md
@@ -10,73 +10,47 @@ https://cgnsorg.atlassian.net
 
 ## Installation
 
-### Installation Instructions using cmake
-
-1. Install HDF5 on your system
-
-    a. HDF5 can use the standard GNU autotools, so './configure',
-    'make', 'sudo make install' should install HDF5 without
-    problems on most systems.
-
-2. Unpack the tar ball containing the source code into some
-  directory.
-
-3. Create a new director in which to build the library.
-
-4. Use cmake to initialize the build tree.
+### Installation Instructions using `cmake`
 
+1. Install HDF5 on your system.
+  
+   - HDF5 can use the standard GNU autotools, so `./configure`, `make`, `sudo make install` should install HDF5 without problems on most systems.
+2. Unpack the tar ball containing the source code into some directory.
+3. Create a new directory in which to build the library.
+4. Use `cmake` to initialize the build tree.
+   ```shell
    user@hostname:build_path$ cmake /path/to/cgns/sources/
-
-5. Use ccmake to edit the control variables as needed.
-
+   ```
+5. Use `ccmake` to edit the control variables as needed.
+   ```shell
    user@hostname:build_path$ ccmake .
-   
-   (a)The path to the HDF5 library should be specified with CMAKE_PREFIX_PATH=$HDF_DIR for linking with a
-      specific HDF5 version.
-         
-     - If HDF5 is built with parallel-IO support via MPI, the 'HDF5_NEEDS_MPI' flag must be set to true.
-
-     - If HDF5 is built with zlib and szip support, these need to be flagged with 'HDF5_NEEDS_ZLIB' and 'HDF5_NEEDS_SZIP' as well as the paths for those libraries.
-
-   (b)Fortran can be enabled by toggling the 'CGNS_ENABLE_FORTRAN' variable.
-
-    - A view of the attempt to autodetect the correct interface
-      between Fortran and C is show, setting the value of
-      'FORTRAN_NAMING'.
-
-    - For gfortran and pgf90 the value of 'FORTRAN_NAMING'
-      shoud be 'LOWERCASE_'.
-
-   (c) The build system must be reconfigured after variable changes by pressing 'c'. Variables who's value has changed are maked with a '*' in the interface.
-
-   (d) After configuration, the Makefiles must be generated by
-    pressing 'g'.
-
-6. Use make to build the library.
-
+   ```
+   - The path to the HDF5 library should be specified with `CMAKE_PREFIX_PATH=$HDF_DIR` for linking with a specific HDF5 version.
+     - If HDF5 is built with parallel-IO support via MPI, the `HDF5_NEEDS_MPI` flag must be set to `true`.
+     - If HDF5 is built with `zlib` and `szip` support, these need to be flagged with `HDF5_NEEDS_ZLIB` and `HDF5_NEEDS_SZIP` as well as the paths for those libraries.
+   - Fortran can be enabled by toggling the `CGNS_ENABLE_FORTRAN` variable.
+     - A view of the attempt to autodetect the correct interface between Fortran and C is show, setting the value of `FORTRAN_NAMING`.
+     - For `gfortran` and `pgf90` the value of `FORTRAN_NAMING` shoud be `LOWERCASE_`.
+   - The build system must be reconfigured after variable changes by pressing `c`. Variables who's value has changed are maked with a `*` in the interface.
+   - After configuration, the `Makefile`s must be generated by pressing `g`.
+6. Use `make` to build the library.
+   ```shell
    user@hostname:build_path$ make
-
-
-   (a) A colorized review of the build process should follow.
-
-7. Installation of the library is accomplished with the 'install' target of the makefile.
-
+   ```
+   - A colorized review of the build process should follow.
+7. Installation of the library is accomplished with the `install` target of the makefile.
+   ```shell
    user@hostname:build_path$ make install
+   ```
+   - You must have permissions to alter the directory where CGNS will be installed.
 
-   (a) You must have permissions to alter the directory where cgns will be installed.
-
-    
-### Installation Instructions using make
-
-1. Install HDF5 on your system
+### Installation Instructions using `make`
 
-    (a) HDF5 can use the standard GNU autotools, so './configure', 'make', 'sudo make install' should install HDF5 without problems on most systems.
-    
-2.  Typically the standard ./configure, make, make install will suffice.  
+1. Install HDF5 on your system.
+   - HDF5 can use the standard GNU autotools, so `./configure`, `make`, `sudo make install` should install HDF5 without problems on most systems.
+2. Typically the standard `./configure`, `make`, `make install` will suffice.  
+3. Sample scripts for building parrallel CGNS can be found in `src/SampleScripts`.
 
-3. Sample scripts for building parrallel CGNS can be found in src/SampleScripts.
- 
-      
 ## Usage
 
 ## License
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index bac373a24bb..b0785ab0d71 100644
--- a/ThirdParty/cgns/vtkcgns/src/CMakeLists.txt
+++ b/ThirdParty/cgns/vtkcgns/src/CMakeLists.txt
@@ -10,7 +10,6 @@ endif (WIN32)
 # Include the local directory
 include_directories(BEFORE ${CMAKE_CURRENT_SOURCE_DIR})
 if (CGNS_ENABLE_HDF5)
-  add_definitions(-DBUILD_HDF5)
   if (FALSE) # XXX(kitware): Handled by ParaView.
   if (WIN32)
     if (HDF5_LIBRARY)
@@ -25,13 +24,10 @@ if (CGNS_ENABLE_HDF5)
     include_directories(${MPI_INC})
   endif(HDF5_NEED_MPI AND MPI_INC)
   endif ()
-  if (CGNS_ENABLE_PARALLEL)
-    add_definitions(-DBUILD_PARALLEL)
-  endif (CGNS_ENABLE_PARALLEL)
 endif (CGNS_ENABLE_HDF5)
 
 ################################
-# create configed header files #
+# create configured header files #
 ################################
 
 if ("${SIZE_OF_LONG}" GREATER 4)
@@ -54,9 +50,6 @@ else (CGNS_ENABLE_LEGACY)
   else (CGNS_ENABLE_64BIT)
   endif (CGNS_ENABLE_64BIT)
 endif (CGNS_ENABLE_LEGACY)
-if (CGNS_ENABLE_LFS)
-  add_definitions(-DHAVE_LSEEK64)
-endif (CGNS_ENABLE_LFS)   
 if (CGNS_ENABLE_SCOPING)
   set(BUILDSCOPE 1)
 endif (CGNS_ENABLE_SCOPING)
@@ -111,13 +104,14 @@ set(HAVE_FORTRAN_2008 0)
 set(HAVE_FORTRAN_2008TS 0)
 set(HDF5_HAVE_MULTI_DATASETS 0)
 set(HDF5_HAVE_COLL_METADATA 0)
+set(HDF5_HAVE_FILE_SPACE_STRATEGY 0)
 set(FORTRAN_DEFAULT_INTEGER_C_INT64_T 0)
 set(HAVE_STAT64_STRUCT 0)
 
 if (BUILDFORTRAN)
 
 #----------- Determine if the Fortran compiler pgi ------------------------
-# The PGI compiler segfaults wehn va_start is called, so we need to add
+# The PGI compiler segfaults when va_start is called, so we need to add
 # a special compiler flag, see CGNS-40.
 #--------------------------------------------------------------------------
 IF (CMAKE_Fortran_COMPILER_ID MATCHES "PGI")
@@ -353,16 +347,12 @@ MACRO (CHECK_HDF5_FEATURE FUNCTION CODE VARIABLE)
         ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/test_HDF.c
         "${CODE}"
     )
-IF (HDF5_LIBRARIES)
-    SET (CHECK_FUNCTION_EXISTS_ADD_LIBRARIES "-DLINK_LIBRARIES:STRING=${HDF5_LIBRARIES}")
-ELSE (HDF5_LIBRARIES)
-    SET (CHECK_FUNCTION_EXISTS_ADD_LIBRARIES)
-ENDIF (HDF5_LIBRARIES)
 SET (CHECK_FUNCTION_EXISTS_ADD_INCLUDE "-DINCLUDE_DIRECTORIES:STRING=${HDF5_INCLUDE_DIR}")
     TRY_COMPILE (${VARIABLE}
         ${CMAKE_BINARY_DIR}
         ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/test_HDF.c
-        CMAKE_FLAGS "${CHECK_FUNCTION_EXISTS_ADD_INCLUDE}" "${CHECK_FUNCTION_EXISTS_ADD_LIBRARIES}"
+        LINK_LIBRARIES ${HDF5_LIBRARY}
+        CMAKE_FLAGS "${CHECK_FUNCTION_EXISTS_ADD_INCLUDE}"
         OUTPUT_VARIABLE OUTPUT
     )
 
@@ -464,6 +454,24 @@ CHECK_HDF5_FEATURE(Collective_metadata
    set(HDF5_HAVE_COLL_METADATA 1)
  endif (CHECK_HDF5_HAVE_COLL_METADATA)
 
+ # Check if HDF5 library has H5Pset_file_space_strategy, HDF5 >= 1.10.1
+ # --------------------------------------------------------------------
+
+CHECK_HDF5_FEATURE(H5Pset_file_space_strategy
+  " 
+ #include \"hdf5.h\"
+ void main(void)
+ {
+   hid_t foo;
+   H5Pset_file_space_strategy(foo, H5F_FSPACE_STRATEGY_FSM_AGGR, 1, (hsize_t)1);
+   return;
+ }
+  "
+   CHECK_HDF5_HAVE_FILE_SPACE_STRATEGY
+ )
+ if (CHECK_HDF5_HAVE_FILE_SPACE_STRATEGY)
+   set(HDF5_HAVE_FILE_SPACE_STRATEGY 1)
+ endif (CHECK_HDF5_HAVE_FILE_SPACE_STRATEGY)
 
 endif (CGNS_ENABLE_HDF5)
 
@@ -558,11 +566,14 @@ endif (CGNS_ENABLE_FORTRAN)
 # Needed to work around a CMake > 3.8 bug on Windows with MSVS and Intel Fortran
 set_property(TARGET cgns_static PROPERTY LINKER_LANGUAGE C)
 
-
 # Build a shared version of the library
 if(CGNS_BUILD_SHARED)
   mark_as_advanced(CLEAR CGNS_USE_SHARED)
-  add_library(cgns_shared SHARED ${cgns_FILES})
+  if (CGNS_ENABLE_FORTRAN)
+    add_library(cgns_shared SHARED ${cgns_FILES} cgns_f.F90)
+  else (CGNS_ENABLE_FORTRAN)
+    add_library(cgns_shared SHARED ${cgns_FILES})
+  endif (CGNS_ENABLE_FORTRAN)
   # under windows we need to define BUILD_DLL
   # and link with the HDF5 libraries to build a dll
   if (WIN32 OR CYGWIN)
diff --git a/src/adf/ADF.h b/src/adf/ADF.h
index b4359d3c5bd..0c1a4e4ae63 100644
--- a/ThirdParty/cgns/vtkcgns/src/adf/ADF.h
+++ b/ThirdParty/cgns/vtkcgns/src/adf/ADF.h
@@ -53,11 +53,12 @@ File:	ADF.h
 
 /***********************************************************************
 	Defines:  These defines are used within the ADF core routines
-	to specify the size in bytes of varoius items.
+	to specify the size in bytes of various items.
    Caution:  Simply changing a define here may not correctly adjust the
 	ADF core code.  These sizes are provided for reference only!
 ***********************************************************************/
 #define ADF_DATA_TYPE_LENGTH        32
+#define ADF_CGIO_DATA_TYPE_LENGTH    2
 #define ADF_DATE_LENGTH             32
 #define ADF_FILENAME_LENGTH       1024
 #define ADF_FORMAT_LENGTH           20
@@ -249,6 +250,7 @@ EXTERN	void	ADF_Put_Name(
 
 EXTERN	void	ADF_Read_All_Data(
 			const double ID,
+                        const char *m_data_type,
 			char *data,
 			int *error_return ) ;
 
@@ -269,6 +271,7 @@ EXTERN	void	ADF_Read_Data(
 			const cgsize_t m_start[],
 			const cgsize_t m_end[],
 			const cgsize_t m_stride[],
+                        const char *m_data_type,
 			char *data,
 			int *error_return ) ;
 
diff --git a/src/adf/ADF_interface.c b/src/adf/ADF_interface.c
index 181085792c0..11c3502069a 100644
--- a/ThirdParty/cgns/vtkcgns/src/adf/ADF_interface.c
+++ b/ThirdParty/cgns/vtkcgns/src/adf/ADF_interface.c
@@ -182,19 +182,19 @@ const char  *ADF_error_string[] = {
    "ADF 50: Too many link level used.  May be caused by a recursive link.",
    "ADF 51: The node is not a link.  It was expected to be a link.",
    "ADF 52: The linked-to node does not exist.",
-   "ADF 53: The ADF file of a linked-node is not accessable.",
+   "ADF 53: The ADF file of a linked-node is not accessible.",
    "ADF 54: A node-id of 0.0 is not valid.",
    "ADF 55: Incomplete Data when reading multiple data blocks.",
    "ADF 56: Node name contains invalid characters.",
    "ADF 57: ADF file version incompatible with this library version.",
    "ADF 58: Nodes are not from the same file.",
    "ADF 59: Priority Stack Error.",
-   "ADF 60: Machine format and file format are incompatable.",
+   "ADF 60: Machine format and file format are incompatible.",
    "ADF 61: FFLUSH error",
    "ADF 62: The node ID pointer is NULL.",
    "ADF 63: The maximum size for a file exceeded.",
    "ADF 64: Dimensions exceed that for a 32-bit integer.",
-   "ADF  x: Last error mesage"
+   "ADF  x: Last error message"
    } ;
 
 /***********************************************************************
@@ -1019,7 +1019,11 @@ void	ADF_Database_Valid(
             *error_return = FILE_OPEN_ERROR;
         return;
     }
-    fread (header, sizeof(char), 32, fp);
+    if (32 != fread (header, sizeof(char), 32, fp)) {
+        *error_return = FREAD_ERROR;
+        fclose (fp);
+        return;
+    }
     fclose (fp);
     header[32] = 0;
     if (strncmp (&header[4], "ADF Database Version", 20))
@@ -1367,7 +1371,7 @@ ADFI_chase_link( ID, &LID, &file_index,  &block_offset, &node, error_return ) ;
 CHECK_ADF_ABORT( *error_return ) ;
 
 	/** Copy the blank-filled data-type into a C string **/
-ADFI_string_2_C_string( node.data_type, ADF_DATA_TYPE_LENGTH, data_type,
+ADFI_string_2_C_string( node.data_type, ADF_CGIO_DATA_TYPE_LENGTH, data_type,
 		error_return ) ;
 CHECK_ADF_ABORT( *error_return ) ;
 
@@ -2597,6 +2601,7 @@ output: int *error_return	Error return.
 ***********************************************************************/
 void	ADF_Read_All_Data(
 		const double ID,
+                const char *m_data_type,
 		char *data,
 		int *error_return )
 {
@@ -2625,7 +2630,16 @@ if( data == NULL ) {
 ADFI_chase_link( ID, &LID, &file_index,  &block_offset, &node, error_return ) ;
 CHECK_ADF_ABORT( *error_return ) ;
 
+/* if it was provided, check to make sure the data types match */
+if( m_data_type != NULL ) {
+  if(strncmp(m_data_type, node.data_type, 2) != 0){
+    *error_return = INVALID_DATA_TYPE;
+    CHECK_ADF_ABORT( *error_return );
+  }
+}
+
 	/** Get datatype size **/
+
 ADFI_evaluate_datatype( file_index, node.data_type, &file_bytes, &memory_bytes,
 	tokenized_data_type, &file_format, &machine_format, error_return ) ;
 CHECK_ADF_ABORT( *error_return ) ;
@@ -2710,7 +2724,7 @@ else {
 /***********************************************************************
 ADF Read Block Data:
 
-Read a continous block of data from a Node.  Reads a block the node's data
+Read a continuous block of data from a Node.  Reads a block the node's data
 and returns it into a contiguous memory space.
 
 ADF_Read_Block_Data( ID, data, error_return )
@@ -2912,6 +2926,7 @@ void	ADF_Read_Data(
 		const cgsize_t m_start[],
 		const cgsize_t m_end[],
 		const cgsize_t m_stride[],
+                const char *m_data_type,
 		char *data,
 		int *error_return )
 {
@@ -2948,6 +2963,14 @@ if( (s_start == NULL) || (s_end == NULL) || (s_stride == NULL) ||
 ADFI_chase_link( ID, &LID, &file_index,  &block_offset, &node, error_return ) ;
 CHECK_ADF_ABORT( *error_return ) ;
 
+/* if it was provided, check to make sure the data types match */
+if( m_data_type != NULL ) {
+  if(strncmp(m_data_type, node.data_type, 2) != 0){
+    *error_return = INVALID_DATA_TYPE;
+    CHECK_ADF_ABORT( *error_return );
+  }
+}
+
 	/** Get datatype length **/
 ADFI_evaluate_datatype( file_index, node.data_type, &file_bytes, &memory_bytes,
 	tokenized_data_type, &disk_format, &machine_format, error_return ) ;
@@ -3057,7 +3080,7 @@ for( disk_elem=0; disk_elem<total_disk_elements; disk_elem++ ) {
       } /* end else */
 
    /** Increment disk pointers, for the special case of one dimensional
-       data we will a simple increment to maximize the throught. Thus for
+       data we will a simple increment to maximize the throughput. Thus for
        block reads you can temporarily change to 1D for the read to
        improve efficiency. Note total size shouldn't change!! **/
       if( disk_elem < total_disk_elements - 1 ) {
@@ -3443,7 +3466,7 @@ else { /** Multiple data chunks **/
 	         (data_chunk_table[i].end.offset -
 			data_chunk_table[i].start.offset) -
 		 (TAG_SIZE + DISK_POINTER_SIZE) ;
-        /** Limit the number of bytes written by whats left to write. **/
+        /** Limit the number of bytes written by what's left to write. **/
             current_bytes = MIN( current_bytes, total_bytes ) ;
             ADFI_write_data_chunk( file_index, &data_chunk_table[i].start,
 		 tokenized_data_type, file_bytes, current_bytes, 0,
@@ -4209,7 +4232,7 @@ if( node.number_of_data_chunks == 1 ) {
       } /* end else */
 
    /** Increment disk/memory pointers, for the special case of one dimensional
-       data we will a simple increment to maximize the throught. Thus for
+       data we will a simple increment to maximize the throughput. Thus for
        block writes you can temporarily change to 1D for the read to
        improve efficiency. Note total size shouldn't change!! **/
       if( disk_elem < total_disk_elements - 1 ) {
diff --git a/src/adf/ADF_internals.c b/src/adf/ADF_internals.c
index a29a28817df..06e75f62aaa 100644
--- a/ThirdParty/cgns/vtkcgns/src/adf/ADF_internals.c
+++ b/ThirdParty/cgns/vtkcgns/src/adf/ADF_internals.c
@@ -277,7 +277,7 @@ enum { FLUSH, FLUSH_CLOSE };
 
     /** Assumed machine variable sizes for the currently supported
         machines. For ordering of data see the Figure_Machine_Format
-	function.  Note that when openning a new file not in the machine
+	function.  Note that when opening a new file not in the machine
 	format these are the sizes used!! **/
 enum { TO_FILE_FORMAT, FROM_FILE_FORMAT } ;
 #define NUMBER_KNOWN_MACHINES 5
@@ -377,7 +377,7 @@ void	ADFI_ASCII_Hex_2_unsigned_int(
 unsigned int	i,	/** Index from 0 to string_length - 1 **/
 		ir,	/** Index from string_length - 1 to 0 **/
 		j,	/** Temoprary integer variable **/
-		num ;	/** Working value of ther number **/
+		num ;	/** Working value of the number **/
 
 if( string == NULL ) {
    *error_return = NULL_STRING_POINTER ;
@@ -857,7 +857,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: sign-bit, 8-bit exponent, 23-bit mantissa
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -870,7 +870,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: 23-bit mantissa, 8-bit exponent, sign-bit
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -999,7 +999,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: sign-bit, 8-bit exponent, 23-bit mantissa
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -1013,7 +1013,7 @@ R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
 Note: Exponent sign:  1 in this bits indicates a positive exponent sign,
    thus bit 62 is the inverse of bit 61 (the sign in the exponent).
    The exception to this is a zero, in which all 64 bits are zero!
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> .mantissia(fraction) X 2^exponent. <<<
    The mantissia is left justified (the leftmost bit is a 1).
      This MUST be done!
@@ -1277,7 +1277,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: sign-bit, 8-bit exponent, 23-bit mantissa
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -1290,7 +1290,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: 23-bit mantissa, 8-bit exponent, sign-bit
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -1841,7 +1841,7 @@ for( i=0; i<MIN( new_length, ADF_NAME_LENGTH ); i++ ) {
    } /* end for */
 
 	/** Name mattched for the length of the new name.
-	    The existing node name must only contian blanks from here
+	    The existing node name must only contain blanks from here
 	**/
 for( ; i<ADF_NAME_LENGTH; i++ ) {
    if( name[i] != ' ' ) {
@@ -1892,7 +1892,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: sign-bit, 8-bit exponent, 23-bit mantissa
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -1905,7 +1905,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: 23-bit mantissa, 8-bit exponent, sign-bit
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -1919,7 +1919,7 @@ R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
 Note: Exponent sign:  1 in this bits indicates a positive exponent sign,
    thus bit 62 is the inverse of bit 61 (the sign in the exponent).
    The exception to this is a zero, in which all 64 bits are zero!
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> .mantissia(fraction) X 2^exponent. <<<
    The mantissia is left justified (the leftmost bit is a 1).
      This MUST be done!
@@ -2148,7 +2148,7 @@ if( (ndim <= 0) || (ndim > 12) ) {
 
 *error_return = NO_ERROR ;
 
-	/** Chek the inputs **/
+	/** Check the inputs **/
 for( i=0; i<ndim; i++ ) {
 
 	/** Check dims[] >=1 **/
@@ -2230,7 +2230,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: sign-bit, 8-bit exponent, 23-bit mantissa
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -2244,7 +2244,7 @@ R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
 Note: Exponent sign:  1 in this bits indicates a positive exponent sign,
    thus bit 62 is the inverse of bit 61 (the sign in the exponent).
    The exception to this is a zero, in which all 64 bits are zero!
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> .mantissia(fraction) X 2^exponent. <<<
    The mantissia is left justified (the leftmost bit is a 1).
      This MUST be done!
@@ -2484,7 +2484,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: sign-bit, 8-bit exponent, 23-bit mantissa
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -2498,7 +2498,7 @@ R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
 Note: Exponent sign:  1 in this bits indicates a positive exponent sign,
    thus bit 62 is the inverse of bit 61 (the sign in the exponent).
    The exception to this is a zero, in which all 64 bits are zero!
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> .mantissia(fraction) X 2^exponent. <<<
    The mantissia is left justified (the leftmost bit is a 1).
      This MUST be done!
@@ -3603,8 +3603,8 @@ if( OK == TRUE ) {
    if( sizeof( double )		!= machine_sizes[i][10] ) OK = FALSE ;
 /* This causes the machine type to not be detected on 64-bit Windows
  * since ints and longs are still 32-bit (IEEE_LITTLE_32_FORMAT),
- * but pointers are 64-bit instead of 32-bit. I dont think it's
- * neccessary to check pointer sizes, since pointers are read or
+ * but pointers are 64-bit instead of 32-bit. I don't think it's
+ * necessary to check pointer sizes, since pointers are read or
  * written to the file - Bruce */
 #if 0
    if( sizeof( char * )		!= machine_sizes[i][11] ) OK = FALSE ;
@@ -3706,7 +3706,7 @@ void  ADFI_file_and_machine_compare(
    } else if( ADF_file[file_index].format  == ADF_this_machine_format ) {
         /** If the file and machine binary type are the same and only the
 	    sizes may be different (like long is 32 or 64), then if all the
-	    sizes are the same then no converion is necessary and ws can avoid
+	    sizes are the same then no conversion is necessary and ws can avoid
 	    the conversion overhead and just do direct read/writes. **/
       if ( tokenized_data_type == NULL ) return ;
       token = -1 ;
@@ -4348,7 +4348,7 @@ if( memory_found != TRUE ) { /* Append memory at end of file **/
 	see if the new allocated chunk will span a block boundary.
 	If it will, then start at the new block if it will fit within
 	the block. This helps efficiency to have file control headers
-        located within a block boundry.
+        located within a block boundary.
 	**/
    if( file_header.end_of_file.offset != DISK_BLOCK_SIZE - 1 ) {
       if( (file_header.end_of_file.offset+size_bytes) >= DISK_BLOCK_SIZE  &&
@@ -5033,7 +5033,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: sign-bit, 8-bit exponent, 23-bit mantissa
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -5046,7 +5046,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: 23-bit mantissa, 8-bit exponent, sign-bit
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -5175,7 +5175,7 @@ I4:	Byte0	Byte1	Byte2	Byte3
 R4:	Byte0	Byte1	Byte2	Byte3
     Bits: sign-bit, 8-bit exponent, 23-bit mantissa
     The sign of the exponent is:  1=positive, 0=negative (NOT 2's complement)
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> 2.mantissia(fraction) X 2^exponent. <<<
 
 R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
@@ -5189,7 +5189,7 @@ R8:	Byte0	Byte1	Byte2	Byte 3	Byte 4	Byte5	Byte6	Byte7
 Note: Exponent sign:  1 in this bits indicates a positive exponent sign,
    thus bit 62 is the inverse of bit 61 (the sign in the exponent).
    The exception to this is a zero, in which all 64 bits are zero!
-    The interpreation of the floating-point number is:
+    The interpretation of the floating-point number is:
 	>>> .mantissia(fraction) X 2^exponent. <<<
    The mantissia is left justified (the leftmost bit is a 1).
      This MUST be done!
@@ -5592,7 +5592,7 @@ ADFI read chunk length:
 	If NOT variable, then determine what type of chunk it is
 	and return a pointer to the end_of_chunk-tag:
 
-	If the incomming pointers are 0 0, then we are looking
+	If the incoming pointers are 0 0, then we are looking
 	at the file header.
 
 input:  const unsigned int file_index	The file index.
@@ -7254,7 +7254,7 @@ if( ((int)file_index >= maximum_files || ADF_file[file_index].in_use == 0) &&
 	     return NO_ERROR;
 	   } /* end if */
 	   else {
-	     /* Type dosn't match so delete the bad entry */
+	     /* Type doesn't match so delete the bad entry */
 	     free(PRISTK[i].stack_data);
 	     PRISTK[i].file_index     = -1;
 	     PRISTK[i].file_block     = 0;
@@ -7406,8 +7406,16 @@ if( (string == NULL) || (c_string == NULL) ) {
 
 *error_return = NO_ERROR ;
 
+	/** Search for early NULL termination **/
+for( iend=0; iend < string_length; iend++ ) {
+   if( string[ iend ] == '\0' ) {
+      break ;
+      } /* end if */
+   } /* end for */
+iend--;
+
 	/** Skip and trailing blanks **/
-for( iend=string_length-1; iend>=0; iend-- ) {
+for( ; iend>=0; iend-- ) {
    if( string[ iend ] != ' ' ) {
       break ;
       } /* end if */
@@ -7452,7 +7460,7 @@ void	ADFI_unsigned_int_2_ASCII_Hex(
 unsigned int	i,	/** Index from 0 to string_length - 1 **/
 		ir,	/** Index from string_length - 1 to 0 **/
 		j,	/** Temoprary integer variable **/
-		num ;	/** Working value of ther number **/
+		num ;	/** Working value of the number **/
 
 if( string == NULL ) {
    *error_return = NULL_STRING_POINTER ;
@@ -7992,7 +8000,7 @@ if( (int)file_index >= maximum_files || ADF_file[file_index].in_use == 0 ) {
 *error_return = NO_ERROR ;
 
      /** If the read buffer overlaps the buffer then reset it to make
-         sure its currrent **/
+         sure its current **/
 
 end_block = file_block+(block_offset+data_length)/DISK_BLOCK_SIZE+1;
 if ( last_rd_file == (int) file_index && last_rd_block >= (cglong_t) file_block &&
@@ -8027,7 +8035,7 @@ if( ( (cgulong_t) data_length + block_offset > DISK_BLOCK_SIZE ||
    } /* end if */
 
      /** If the write buffer overlaps the buffer then reset it to make
-         sure its currrent, set flush buffer flag to false. **/
+         sure its current, set flush buffer flag to false. **/
    if ( last_wr_file == (int) file_index && last_wr_block >= (cglong_t) file_block &&
        last_wr_block <= (cglong_t) end_block ) {
       last_wr_block = -2;
@@ -8059,7 +8067,7 @@ if( data_length + block_offset > DISK_BLOCK_SIZE ) {
 } /* end if */
 
     /** For smaller pieces of data, write a block at a time.  This will improve
-        performance if neighboring data is writen a small piece at a time
+        performance if neighboring data is written a small piece at a time
         (strided reads, file overhead).
 
         Some assumptions apply to the block size.  With some experimenting,
@@ -8902,14 +8910,14 @@ ADFI_stack_control(file_index, block_offset->block,
 /* file ADFI_strtok.c */
 /***********************************************************************
 ADFI get string token: This routine simulates strtok except it returns the
-current postion in the string tobe used later. Thas avoids the problem of
-trying using strtok in a recrusive subroutine call which does not work!
+current position in the string tobe used later. Thas avoids the problem of
+trying using strtok in a recursive subroutine call which does not work!
 
 input/output:  *string     - the string to parse tokens from.
                              returns string with token replaced by nil.
 input/output:  *string_pos - the string position to begin parsing should
                              be placed at the beginning of the string.
-                             returns postion after last token to continue
+                             returns position after last token to continue
 			     string parsing. Token may change from last call.
 input:         *token      - The token to search for.
 function return:           - a pointer to the desired substring.
@@ -8946,7 +8954,7 @@ char   *ADFI_strtok(
      } /* end while */
   if ( string_len == 0 ) return NULL ;
 
-  /* Set the begining fof the sub string */
+  /* Set the beginning of the sub string */
   sub_string = tmp_ptr ;
 
   /* Find the next token or the end of the string */
diff --git a/src/adfh/ADFH.c b/src/adfh/ADFH.c
index 234b63c9742..87516b3ec25 100644
--- a/ThirdParty/cgns/vtkcgns/src/adfh/ADFH.c
+++ b/ThirdParty/cgns/vtkcgns/src/adfh/ADFH.c
@@ -42,7 +42,7 @@ freely, subject to the following restrictions:
 #include "vtk_hdf5.h"
 #include "cgns_io.h" /* for cgio_find_file */
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
 #include "mpi.h"
 extern int pcg_mpi_initialized;
 extern MPI_Info pcg_mpi_info;
@@ -59,12 +59,15 @@ extern hid_t default_pio_mode;
 
 static int CompressData = -1;
 
-#ifdef BUILD_PARALLEL
-static MPI_Comm ParallelMPICommunicator = MPI_COMM_WORLD;
+#if CG_BUILD_PARALLEL
+static MPI_Comm ParallelMPICommunicator = MPI_COMM_NULL;
 #endif
 
 #define TO_UPPER( c ) ((islower(c))?(toupper(c)):(c))
 
+/* HDF5 compact storage limit */
+#define CGNS_64KB (64 * 1024)
+
 /*
  * ADF names are not allowed to start with a space.
  * Since HDF5 allows this, use the space to hide data
@@ -107,8 +110,8 @@ printf("#### DBG [%5d] ",__LINE__);fflush(stdout); \
 printf aaa ; printf("\n"); fflush(stdout);
 #define DROP( msg ) printf("XX " msg "\n");fflush(stdout);
 #else
-#define ADFH_DEBUG(a) ;
-#define DROP( msg ) ;
+#define ADFH_DEBUG(a) {;}
+#define DROP( msg ) {;}
 #endif
 
 /* ADF data types */
@@ -203,7 +206,7 @@ static struct _ErrorList {
   {UNEQUAL_MEMORY_AND_DISK_DIMS,"Unequal dimensional specifications for disk and memory"},
   {NODE_IS_NOT_A_LINK,      "The node is not a link.  It was expected to be a link"},
   {LINK_TARGET_NOT_THERE,   "The linked-to node does not exist"},
-  {LINKED_TO_FILE_NOT_THERE,"The file of a linked-node is not accessable"},
+  {LINKED_TO_FILE_NOT_THERE,"The file of a linked-node is not accessible"},
   {INVALID_NODE_NAME,       "Node name contains invalid characters"},
   {FFLUSH_ERROR,            "H5Fflush:flush error"},
   {NULL_NODEID_POINTER,     "The node ID pointer is NULL"},
@@ -253,13 +256,13 @@ static struct _ErrorList {
   {ADFH_ERR_SENTINEL,       "<None>"}
 };
 
-#define NUM_ERRORS (sizeof(ErrorList)/sizeof(struct _ErrorList))
+#define NUM_ERRORS ((int)(sizeof(ErrorList)/sizeof(struct _ErrorList)))
 #define ROOT_OR_DIE(err) \
 if (mta_root == NULL){set_error(ADFH_ERR_ROOTNULL, err);return;}
 #define ROOT_OR_DIE_ERR(err) \
 if (mta_root == NULL){set_error(ADFH_ERR_ROOTNULL, err);return 1;}
 
-/* usefull macros */
+/* useful macros */
 
 #define CMP_OSTAT(r,n) ((r)->objno[0]==(n)->objno[0] && \
                         (r)->objno[1]==(n)->objno[1] && \
@@ -322,7 +325,7 @@ static herr_t walk_H5_error(hid_t estack, void *data)
     fflush(stdout);
     fprintf(stderr, "\nHDF5 Error Trace Back\n");
     return H5Ewalk2(H5E_DEFAULT, H5E_WALK_DOWNWARD,
-		    (H5E_walk2_t)print_H5_error, data);
+                    (H5E_walk2_t)print_H5_error, data);
   }
   return 0;
 }
@@ -333,7 +336,7 @@ static herr_t walk_H5_error(hid_t estack, void *data)
 
 static hid_t get_file_id (hid_t id)
 {
-  int n, nobj;
+  ssize_t n, nobj;
   hid_t *objs, fid = -1;
   H5G_stat_t gstat, rstat;
 
@@ -384,10 +387,8 @@ static track_id(hid_t refid, hid_t trackid)
   int fn,er;
   int sname;
   char oname[256];
-  H5O_info_t objinfo;
   size_t maxhid;
 
-  H5Oget_info(trackid,&objinfo);
   memset(oname,'\0',256);
   sname=H5Iget_name(trackid,oname,0);
   sname=H5Iget_name(trackid,oname,sname+1);
@@ -404,12 +405,12 @@ static track_id(hid_t refid, hid_t trackid)
       maxhid=mta_root->x_extids[fn]*sizeof(hid_t*);
       mta_root->g_extids[fn]=(hid_t*)realloc(mta_root->g_extids[fn],maxhid);
       ADFH_DEBUG((">ADFH track_ids realloc up to [%d]",\
-		  mta_root->x_extids[fn]));
+                  mta_root->x_extids[fn]));
 
     }
     mta_root->g_extids[fn][mta_root->n_extids[fn]]=trackid;
     ADFH_DEBUG((">ADFH track_ids [%d][%d][%s]",\
-		mta_root->n_extids[fn],trackid,oname));
+                mta_root->n_extids[fn],trackid,oname));
     mta_root->n_extids[fn]++;
   }
 }
@@ -713,6 +714,7 @@ static int new_str_data(hid_t id, const char *name, const char *value,
   hsize_t dim;
   herr_t status;
   hid_t xfer_prp=H5P_DEFAULT;
+  hid_t dcpl_id=H5P_DEFAULT;
 
   dim = size+1;
   sid = H5Screate_simple(1, &dim, NULL);
@@ -721,14 +723,26 @@ static int new_str_data(hid_t id, const char *name, const char *value,
     return 1;
   }
 
-  did = H5Dcreate2(id, name, H5T_NATIVE_CHAR, sid, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+  dcpl_id = H5Pcreate(H5P_DATASET_CREATE);
+
+  /* compact storage */
+  if(size+1 < CGNS_64KB)
+    H5Pset_layout(dcpl_id, H5D_COMPACT);
+  else {
+    H5Pset_layout(dcpl_id, H5D_CONTIGUOUS);
+    H5Pset_alloc_time(dcpl_id, H5D_ALLOC_TIME_EARLY);
+    H5Pset_fill_time(dcpl_id, H5D_FILL_TIME_NEVER); 
+  }
+
+  did = H5Dcreate2(id, name, H5T_NATIVE_CHAR, sid, H5P_DEFAULT, dcpl_id, H5P_DEFAULT);
   if (did < 0) {
     H5Sclose(sid);
+    H5Pclose(dcpl_id);
     set_error(ADFH_ERR_DCREATE, err);
     return 1;
   }
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   if (pcg_mpi_initialized) {
     xfer_prp = H5Pcreate(H5P_DATASET_XFER);
     H5Pset_dxpl_mpio(xfer_prp, H5FD_MPIO_COLLECTIVE);
@@ -737,7 +751,7 @@ static int new_str_data(hid_t id, const char *name, const char *value,
 
   status = H5Dwrite(did, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL, xfer_prp, value);
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   if (pcg_mpi_initialized) {
     H5Pclose(xfer_prp);
   }
@@ -745,6 +759,7 @@ static int new_str_data(hid_t id, const char *name, const char *value,
 
   H5Dclose(did);
   H5Sclose(sid);
+  H5Pclose(dcpl_id);
 
   if (status < 0) {
     set_error(ADFH_ERR_DWRITE, err);
@@ -857,7 +872,7 @@ static herr_t count_children(hid_t id, const char *name, void *number)
 /* ----------------------------------------------------------------- */
 
 static herr_t children_names(hid_t id, const char *name,
-			     const H5L_info_t *linfo, void *namelist)
+                             const H5L_info_t *linfo, void *namelist)
 {
 #ifndef ADFH_NO_ORDER
   hid_t gid;
@@ -896,7 +911,7 @@ static herr_t children_names(hid_t id, const char *name,
 
 /* ----------------------------------------------------------------- */
 static herr_t children_ids(hid_t id, const char *name,
-			   const H5L_info_t *linfo, void *idlist)
+                           const H5L_info_t *linfo, void *idlist)
 
 {
   hid_t gid;
@@ -1007,7 +1022,7 @@ static hid_t open_link(hid_t id, int *err)
 
   const char  *file;
   const char  *path;
-  H5G_stat_t	sb; /* Object information */
+  H5G_stat_t  sb; /* Object information */
 
   char  querybuff[512];
 
@@ -1059,8 +1074,8 @@ static hid_t open_link(hid_t id, int *err)
     ADFH_DEBUG((">ADFH open_link (external)"));
     if ((lid = H5Gopen2(id, D_LINK, H5P_DEFAULT)) < 0)
       {
-	set_error(LINK_TARGET_NOT_THERE, err);
-	return lid;
+        set_error(LINK_TARGET_NOT_THERE, err);
+        return lid;
       }
   }
   else
@@ -1068,8 +1083,8 @@ static hid_t open_link(hid_t id, int *err)
     ADFH_DEBUG((">ADFH open_link (symbolic)"));
     if ((lid = H5Gopen2(id, D_LINK, H5P_DEFAULT)) < 0)
       {
-	set_error(LINK_TARGET_NOT_THERE, err);
-	return lid;
+        set_error(LINK_TARGET_NOT_THERE, err);
+        return lid;
       }
   }
 #ifdef ADFH_DEBUG_ON
@@ -1360,7 +1375,7 @@ void ADFH_Configure(const int option, const void *value, int *err)
             CompressData = compress;
         set_error(NO_ERROR, err);
     }
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
     else if (option == ADFH_CONFIG_MPI_COMM) {
       MPI_Comm* comm = (MPI_Comm*)value;
       if (!comm) {
@@ -1368,7 +1383,7 @@ void ADFH_Configure(const int option, const void *value, int *err)
       }
       else {
         ParallelMPICommunicator = (MPI_Comm)*comm;
-	set_error(NO_ERROR, err);
+        set_error(NO_ERROR, err);
       }
     }
 #endif
@@ -1388,7 +1403,8 @@ void ADFH_Move_Child(const double  pid,
   hid_t hpid;
   hid_t hid;
   hid_t hnpid;
-  int len, namelen;
+  ssize_t len;
+  int namelen;
 #ifndef ADFH_NO_ORDER
   int old_order, new_order;
 #endif
@@ -1625,7 +1641,7 @@ void ADFH_Create(const double  pid,
 
   *id = 0;
   gid = H5Gcreate2(hpid, pname,
-		   H5P_DEFAULT, mta_root->g_propgroupcreate, H5P_DEFAULT);
+                   H5P_DEFAULT, mta_root->g_propgroupcreate, H5P_DEFAULT);
 #ifdef ADFH_DEBUG_ON
   H5Lget_info(hpid,pname,&lkbuff,H5P_DEFAULT);
   ADFH_DEBUG((">ADFH_Create [%s] index [%d]",pname,lkbuff.corder));
@@ -1843,11 +1859,11 @@ void ADFH_Children_Names(const double pid,
   memset(names, 0, ilen*name_length);
   if ((hpid = open_node(pid, err)) >= 0) {
     H5Literate(hpid,H5_INDEX_CRT_ORDER,H5_ITER_INC,
-	       NULL,children_names,(void *)names);
+               NULL,children_names,(void *)names);
     if (names[0]==0)
     {
       H5Literate(hpid,H5_INDEX_NAME,H5_ITER_INC,
-		 NULL,children_names,(void *)names);
+                 NULL,children_names,(void *)names);
     }
     H5Gclose(hpid);
   }
@@ -1883,11 +1899,11 @@ void ADFH_Children_IDs(const double pid,
 #endif
   if ((hpid = open_node(pid, err)) >= 0) {
     H5Literate(hpid,H5_INDEX_CRT_ORDER,H5_ITER_INC,
-	       NULL,children_ids,(void *)IDs);
+               NULL,children_ids,(void *)IDs);
     if (IDs[0]==-1)
     {
       H5Literate(hpid,H5_INDEX_NAME,H5_ITER_INC,
-		 NULL,children_ids,(void *)IDs);
+                 NULL,children_ids,(void *)IDs);
     }
     H5Gclose(hpid);
   }
@@ -1943,15 +1959,17 @@ void ADFH_Database_Open(const char   *name,
     for (i = 0; i < ADFH_MAXIMUM_FILES; i++) mta_root->g_files[i] = 0;
     mta_root->g_init = 1;
 
-    /* create properties - these are persistent accross all open files.
+    /* create properties - these are persistent across all open files.
        When all files are closed, then delete properties */
     /* H5Pclose performed at file close time */
     mta_root->g_proplink=H5Pcreate(H5P_LINK_ACCESS);
     H5Pset_nlinks(mta_root->g_proplink, ADF_MAXIMUM_LINK_DEPTH);
     mta_root->g_propgroupcreate=H5Pcreate(H5P_GROUP_CREATE);
     H5Pset_link_creation_order(mta_root->g_propgroupcreate,
-			     H5P_CRT_ORDER_TRACKED | H5P_CRT_ORDER_INDEXED);
+                               H5P_CRT_ORDER_TRACKED | H5P_CRT_ORDER_INDEXED);
     mta_root->g_propdataset=H5Pcreate(H5P_DATASET_CREATE);
+    H5Pset_alloc_time(mta_root->g_propdataset, H5D_ALLOC_TIME_EARLY);
+    H5Pset_fill_time(mta_root->g_propdataset, H5D_FILL_TIME_NEVER); 
   }
 
   if (name == NULL || stat == NULL || fmt == NULL) {
@@ -2029,25 +2047,29 @@ void ADFH_Database_Open(const char   *name,
     return;
   }
 
-  // Patch from Manuel Gageik on IBM BLUEgene/Q systems for better cgp_open performance.
+  /* Patch from Manuel Gageik on IBM BLUEgene/Q systems for better cgp_open performance. */
 #ifdef JFC_PATCH_2015_2
 
-  // http://www.hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_meta_block_size.htm
-  // default setting is 2048 bytes
-  H5Pset_meta_block_size(g_propfileopen, 4096);  // 1024*1024
+  /* http://www.hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_meta_block_size.htm
+   * default setting is 2048 bytes
+   */
+  H5Pset_meta_block_size(g_propfileopen, 4096);  /* 1024*1024 */
 
-  // http://hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_alignment.htm
-  // attention: this can increase filesize dramatically if lots of small datasets
+  /* http://hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_alignment.htm
+   * attention: this can increase filesize dramatically if lots of small datasets
+   */
   H5Pset_alignment(g_propfileopen, 4096, 4096);
 
-  // http://www.hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_buffer.htm
-  // 1 MByte is default of hdf5
+  /* http://www.hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_buffer.htm
+   * 1 MByte is default of hdf5
+   */
   void *tconv; void *bkg;
   H5Pset_buffer(g_propfileopen, 10*1024*1024,tconv, bkg);
 
-  // http://hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-SetSieveBufSize
-  // '..  used by file drivers that are capable of using data sieving'
-  //  1 MByte is default of hdf5
+  /* http://hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-SetSieveBufSize
+   * '..  used by file drivers that are capable of using data sieving'
+   *  1 MByte is default of hdf5
+   */
   H5Pset_sieve_buf_size(g_propfileopen, 4*1024*1024);
 
 #endif
@@ -2068,7 +2090,7 @@ void ADFH_Database_Open(const char   *name,
 #endif
   /* open the file */
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   int flag = 0;
   /* check if we are actually running a parallel program */
   MPI_Initialized(&flag);
@@ -2093,30 +2115,40 @@ void ADFH_Database_Open(const char   *name,
 
 #ifdef JFC_PATCH_2015_2
 
-  // http://www.hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_meta_block_size.htm
-  // default setting is 2048 bytes
+  /* http://www.hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_meta_block_size.htm
+   * default setting is 2048 bytes
+   */
   H5Pset_meta_block_size(g_propfilecreate, 4096);  // 1024*1024
 
-  // http://hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_alignment.htm
-  // attention: this can increase filesize dramatically if lots of small datasets
+  /* http://hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_alignment.htm
+   * attention: this can increase filesize dramatically if lots of small datasets
+   */
   H5Pset_alignment(g_propfilecreate, 4096, 4096);
 
-  // http://www.hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_buffer.htm
-  // 1 MByte is default of hdf5
+  /* http://www.hdfgroup.org/HDF5/doc/RM/H5P/H5Pset_buffer.htm
+   * 1 MByte is default of hdf5
+   */
   void *tconv; void *bkg;
   H5Pset_buffer(g_propfilecreate, 10*1024*1024,tconv, bkg);
 
-  // http://hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-SetSieveBufSize
-  // '..  used by file drivers that are capable of using data sieving'
-  //  1 MByte is default of hdf5
+  /* http://hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-SetSieveBufSize
+   * '..  used by file drivers that are capable of using data sieving'
+   * 1 MByte is default of hdf5
+   */
   H5Pset_sieve_buf_size(g_propfilecreate, 4*1024*1024);
 
+#endif
+
+#if 0 /* MSB -- DISABLED as it is not compatible with HDF5 1.8 file format, need to resolve this CGNS-166 */
+#if HDF5_HAVE_FILE_SPACE_STRATEGY
+    H5Pset_file_space_strategy(g_propfilecreate, H5F_FSPACE_STRATEGY_FSM_AGGR, 1, (hsize_t)1);
+#endif
 #endif
 
     /* add creation time for groups (used by iterators)
       (prop set to file creation )*/
     H5Pset_link_creation_order(g_propfilecreate,
-			     H5P_CRT_ORDER_TRACKED | H5P_CRT_ORDER_INDEXED);
+                               H5P_CRT_ORDER_TRACKED | H5P_CRT_ORDER_INDEXED);
     fid = H5Fcreate(name, H5F_ACC_TRUNC, g_propfilecreate, g_propfileopen);
     H5Pclose(g_propfilecreate);
     H5Pclose(g_propfileopen);
@@ -2143,7 +2175,7 @@ void ADFH_Database_Open(const char   *name,
       set_error(ADFH_ERR_NOT_HDF5_FILE, err);
       return;
     }
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
 #if HDF5_HAVE_COLL_METADATA
     H5Pset_all_coll_metadata_ops( g_propfileopen, 1 );
 #endif
@@ -2216,7 +2248,7 @@ void ADFH_Database_Get_Format(const double  rootid,
     return;
   }
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   hid_t fid = get_file_id(hid);
   hid_t fapl=H5Fget_access_plist(fid);
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
@@ -2228,7 +2260,7 @@ void ADFH_Database_Get_Format(const double  rootid,
 
   status = H5Dread(did, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL, xfer_prp, format);
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
     H5Pclose(xfer_prp);
   }
@@ -2272,7 +2304,7 @@ void ADFH_Database_Close(const double  root,
 {
   int fn,idx;
   hid_t hid,fid;
-  int nobj,n;
+  ssize_t nobj,n;
 #ifdef ADFH_FORCE_ID_CLOSE
   hid_t *objs;
 #endif
@@ -2299,7 +2331,7 @@ void ADFH_Database_Close(const double  root,
   for (nobj=0;nobj<mta_root->n_extids[fn];nobj++)
   {
     ADFH_DEBUG(("ADFH_Database_Close 3 [%.6d/%.6d]:[%d]",\
-		nobj,mta_root->n_extids[fn],mta_root->g_extids[fn][nobj]));
+                nobj,mta_root->n_extids[fn],mta_root->g_extids[fn][nobj]));
     if (H5Iis_valid(mta_root->g_extids[fn][nobj]))
     {
       H5Oclose(mta_root->g_extids[fn][nobj]);
@@ -2595,14 +2627,14 @@ void ADFH_Get_Dimension_Values(const double  id,
         if (ndims > 1) swap = swap_dimensions(hid);
 #endif
         if (swap) {
-	  for (i = 0; i < ndims; i++) {
+          for (i = 0; i < ndims; i++) {
             dim_vals[i] = (cgsize_t)temp_vals[ndims-1-i];
-	  }
+          }
         }
         else {
-	  for (i = 0; i < ndims; i++) {
+          for (i = 0; i < ndims; i++) {
             dim_vals[i] = (cgsize_t)temp_vals[i];
-	  }
+          }
         }
       }
       H5Sclose(sid);
@@ -2618,16 +2650,14 @@ void ADFH_Put_Dimension_Information(const double   id,
                                     const char    *data_type,
                                     const int      dims,
                                     const cgsize_t dim_vals[],
+                                    const int      HDF5storage_type,
                                     int           *err)
 {
   hid_t hid;
-  hid_t did, tid, sid, mid;
+  hid_t did, tid, sid;
   int i, swap = 0;
-  hsize_t old_size;
-  hsize_t old_dims[ADF_MAX_DIMENSIONS];
   hsize_t new_dims[ADF_MAX_DIMENSIONS];
   char new_type[3];
-  hid_t xfer_prp = H5P_DEFAULT;
 
   to_HDF_ID(id,hid);
 
@@ -2672,7 +2702,6 @@ void ADFH_Put_Dimension_Information(const double   id,
    * in these rare cases.
    */
 
-  old_size = 0;
   if(has_data(hid)) {
     ADFH_DEBUG(("ADFH_Put_Dimension_Information unlink [%d]",hid));
     H5Gunlink(hid, D_DATA);
@@ -2714,9 +2743,23 @@ void ADFH_Put_Dimension_Information(const double   id,
   H5Pset_chunk(mta_root->g_propdataset, dims, new_dims);
 #endif
 
+  hssize_t dset_size = H5Sget_select_npoints(sid);
+  size_t dtype_size = H5Tget_size(tid); 
+
+  /* Chunked datasets are currently not supported */
+
+  /* Compact storage has a dataset size limit of 64 KiB */
+  if(HDF5storage_type == CGIO_COMPACT && dset_size*(hssize_t)dtype_size  < (hssize_t)CGNS_64KB)
+    H5Pset_layout(mta_root->g_propdataset, H5D_COMPACT);
+  else{
+    H5Pset_layout(mta_root->g_propdataset, H5D_CONTIGUOUS);
+    H5Pset_alloc_time(mta_root->g_propdataset, H5D_ALLOC_TIME_EARLY);
+    H5Pset_fill_time(mta_root->g_propdataset, H5D_FILL_TIME_NEVER); 
+  }
+
   ADFH_CHECK_HID(sid);
   did = H5Dcreate2(hid, D_DATA, tid, sid,
-		   H5P_DEFAULT, mta_root->g_propdataset, H5P_DEFAULT);
+                   H5P_DEFAULT, mta_root->g_propdataset, H5P_DEFAULT);
 /*  H5Eprint1(stdout);*/
   ADFH_CHECK_HID(did);
 
@@ -2749,7 +2792,7 @@ void ADFH_Get_Link_Path(const double  id,
     return;
   }
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   if (pcg_mpi_initialized) {
     xfer_prp = H5Pcreate(H5P_DATASET_XFER);
     ADFH_CHECK_HID(xfer_prp);
@@ -2773,7 +2816,7 @@ void ADFH_Get_Link_Path(const double  id,
     *filename = 0;
   }
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   if (pcg_mpi_initialized) {
     H5Pclose(xfer_prp);
   }
@@ -2817,11 +2860,11 @@ void ADFH_Link(const double  pid,
      because we cannot have a node ID  and a link on this ID (can we?)
      set actual link to D_LINK name (not the current node) */
   H5Lcreate_external(file,
-		     name_in_file,
-		     lid,
-		     D_LINK,
-		     H5P_DEFAULT,
-		     mta_root->g_proplink);
+                     name_in_file,
+                     lid,
+                     D_LINK,
+                     H5P_DEFAULT,
+                     mta_root->g_proplink);
   }
   else
   {
@@ -2849,6 +2892,7 @@ void ADFH_Link(const double  pid,
   if (new_str_data(lid,D_PATH,name_in_file,(int)strlen(name_in_file),err)) return;
   if (*file && new_str_data(lid,D_FILE,file,(int)strlen(file),err))        return;
 #ifndef ADFH_FORCE_ID_CLOSE
+  hid_t hid;
   to_HDF_ID(pid,hid);
   track_id(hid,lid);
 #endif
@@ -2922,7 +2966,7 @@ void ADFH_Database_Version(const double  root_id,
     return;
 #endif
   }
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   hid_t fid = get_file_id(hid);
   hid_t fapl=H5Fget_access_plist(fid);
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
@@ -2932,7 +2976,7 @@ void ADFH_Database_Version(const double  root_id,
 #endif
   status = H5Dread(did, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL, xfer_prp, buff);
   H5Dclose(did);
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
 
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
     H5Pclose(xfer_prp);
@@ -3010,10 +3054,11 @@ void ADFH_Get_Error_State(int *error_state,
 void ADFH_Read_Block_Data(const double ID,
                       const cgsize_t b_start,
                       const cgsize_t b_end,
-                      char *data,
+                      const char *m_data_type,
+                      void *data,
                       int *err )
 {
-  hid_t hid, did, mid, tid, dspace;
+  hid_t hid, did, mid, dspace;
   size_t size, count, offset;
   char *buff;
   hid_t xfer_prp = H5P_DEFAULT;
@@ -3061,22 +3106,25 @@ void ADFH_Read_Block_Data(const double ID,
    * b_start and b_end, just read all the data into a
    * 1-d array and copy the range we want */
 
-  tid = H5Dget_type(did);
-  ADFH_CHECK_HID(tid);
-  mid = H5Tget_native_type(tid, H5T_DIR_ASCEND);
+  if (m_data_type) {
+    mid = to_HDF_data_type(m_data_type);
+  }
+  else {
+    set_error(INVALID_DATA_TYPE, err);
+    return;
+  }
   ADFH_CHECK_HID(mid);
   size = H5Tget_size(mid);
 
   if ((buff = (char *) malloc (size * count)) == NULL) {
     H5Tclose(mid);
-    H5Tclose(tid);
     H5Dclose(did);
     H5Gclose(hid);
     set_error(MEMORY_ALLOCATION_FAILED, err);
     return;
   }
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   hid_t fid = get_file_id(hid);
   hid_t fapl=H5Fget_access_plist(fid);
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
@@ -3096,13 +3144,12 @@ void ADFH_Read_Block_Data(const double ID,
   }
 
   free (buff);
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
     H5Pclose(xfer_prp);
   }
 #endif
   H5Tclose(mid);
-  H5Tclose(tid);
   H5Dclose(did);
   H5Gclose(hid);
 }
@@ -3113,17 +3160,17 @@ void ADFH_Read_Data(const double ID,
                     const cgsize_t s_start[],
                     const cgsize_t s_end[],
                     const cgsize_t s_stride[],
-                    const char *m_data_type,
                     const int m_num_dims,
                     const cgsize_t m_dims[],
                     const cgsize_t m_start[],
                     const cgsize_t m_end[],
                     const cgsize_t m_stride[],
+                    const char *m_data_type,
                     char *data,
                     int *err )
 {
   int n, ndim;
-  hid_t hid, did, mid, tid, dspace, mspace;
+  hid_t hid, did, mid, dspace, mspace;
   hsize_t dims[ADF_MAX_DIMENSIONS];
   hsize_t start[ADF_MAX_DIMENSIONS];
   hsize_t stride[ADF_MAX_DIMENSIONS];
@@ -3248,17 +3295,16 @@ void ADFH_Read_Data(const double ID,
 
   /* read the data */
 
-  tid = H5Dget_type(did);
-  ADFH_CHECK_HID(tid);
   if (m_data_type) {
     mid = to_HDF_data_type(m_data_type);
   }
   else {
-    mid = H5Tget_native_type(tid, H5T_DIR_ASCEND);
+    set_error(INVALID_DATA_TYPE, err);
+    return;
   }
   ADFH_CHECK_HID(mid);
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   hid_t fid = get_file_id(hid);
   hid_t fapl=H5Fget_access_plist(fid);
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
@@ -3270,7 +3316,7 @@ void ADFH_Read_Data(const double ID,
 
   status = H5Dread(did, mid, mspace, dspace, xfer_prp, data);
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
     H5Pclose(xfer_prp);
   }
@@ -3278,7 +3324,6 @@ void ADFH_Read_Data(const double ID,
   H5Sclose(mspace);
   H5Sclose(dspace);
   H5Tclose(mid);
-  H5Tclose(tid);
   H5Dclose(did);
   H5Gclose(hid);
 
@@ -3295,7 +3340,7 @@ void ADFH_Read_All_Data(const double  id,
                         char         *data,
                         int          *err)
 {
-  hid_t hid, did, tid, mid;
+  hid_t hid, did, mid;
   hid_t xfer_prp = H5P_DEFAULT;
 
   ADFH_DEBUG(("ADFH_Read_All_Data"));
@@ -3305,16 +3350,15 @@ void ADFH_Read_All_Data(const double  id,
   if (has_data(hid)) {
     did = H5Dopen2(hid, D_DATA, H5P_DEFAULT);
     ADFH_CHECK_HID(did);
-    tid = H5Dget_type(did);
-    ADFH_CHECK_HID(tid);
     if (m_data_type) {
       mid = to_HDF_data_type(m_data_type);
     }
     else {
-      mid = H5Tget_native_type(tid, H5T_DIR_ASCEND);
+      set_error(INVALID_DATA_TYPE, err);
+      return;
     }
     ADFH_CHECK_HID(mid);
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
     if (pcg_mpi_initialized) {
       xfer_prp = H5Pcreate(H5P_DATASET_XFER);
       ADFH_CHECK_HID(xfer_prp);
@@ -3326,13 +3370,12 @@ void ADFH_Read_All_Data(const double  id,
     else
       set_error(NO_ERROR, err);
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
     if (pcg_mpi_initialized) {
       H5Pclose(xfer_prp);
     }
 #endif
     H5Tclose(mid);
-    H5Tclose(tid);
     H5Dclose(did);
   }
   else
@@ -3412,7 +3455,7 @@ void ADFH_Write_Block_Data(const double ID,
     return;
   }
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
     hid_t fid = get_file_id(hid);
     hid_t fapl=H5Fget_access_plist(fid);
     if (H5Pget_driver(fapl) == H5FD_MPIO) {
@@ -3435,7 +3478,7 @@ void ADFH_Write_Block_Data(const double ID,
   }
 
   free (buff);
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
     if (H5Pget_driver(fapl) == H5FD_MPIO) {
       H5Pclose(xfer_prp);
     }
@@ -3598,7 +3641,7 @@ void ADFH_Write_Data(const double ID,
   }
   ADFH_CHECK_HID(mid);
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   hid_t fid = get_file_id(hid);
   hid_t fapl=H5Fget_access_plist(fid);
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
@@ -3610,7 +3653,7 @@ void ADFH_Write_Data(const double ID,
 
   status = H5Dwrite(did, mid, mspace, dspace, xfer_prp, data);
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
   if (H5Pget_driver(fapl) == H5FD_MPIO) {
     H5Pclose(xfer_prp);
   }
@@ -3663,12 +3706,12 @@ void ADFH_Write_All_Data(const double  id,
       mid = H5Tget_native_type(tid, H5T_DIR_ASCEND);
     }
     ADFH_CHECK_HID(mid);
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
     if (pcg_mpi_initialized) {
       xfer_prp = H5Pcreate(H5P_DATASET_XFER);
       ADFH_CHECK_HID(xfer_prp);
       if (H5Pset_dxpl_mpio(xfer_prp, H5FD_MPIO_COLLECTIVE) < 0)
-	set_error(ADFH_ERR_DWRITE, err);
+        set_error(ADFH_ERR_DWRITE, err);
     }
 #endif
 
@@ -3676,7 +3719,7 @@ void ADFH_Write_All_Data(const double  id,
       set_error(ADFH_ERR_DWRITE, err);
     else
       set_error(NO_ERROR, err);
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
     if (pcg_mpi_initialized) {
       H5Pclose(xfer_prp);
     }
diff --git a/src/adfh/ADFH.h b/src/adfh/ADFH.h
index 048aed4e97c..fe80f5c622d 100644
--- a/ThirdParty/cgns/vtkcgns/src/adfh/ADFH.h
+++ b/ThirdParty/cgns/vtkcgns/src/adfh/ADFH.h
@@ -350,6 +350,7 @@ EXTERN	void	ADFH_Put_Dimension_Information(
 			const char *data_type,
 			const int dims,
 			const cgsize_t dim_vals[],
+                        const int HDF5storage_type,
 			int *error_return ) ;
 
 EXTERN	void	ADFH_Put_Name(
@@ -368,7 +369,8 @@ EXTERN	void	ADFH_Read_Block_Data(
 			const double ID,
 			const cgsize_t b_start,
 			const cgsize_t b_end,
-			char *data,
+                        const char *m_data_type,
+			void *data,
 			int *error_return ) ;
 
 EXTERN	void	ADFH_Read_Data(
@@ -376,12 +378,12 @@ EXTERN	void	ADFH_Read_Data(
 			const cgsize_t s_start[],
 			const cgsize_t s_end[],
 			const cgsize_t s_stride[],
-                        const char *m_data_type,
 			const int m_num_dims,
 			const cgsize_t m_dims[],
 			const cgsize_t m_start[],
 			const cgsize_t m_end[],
 			const cgsize_t m_stride[],
+                        const char *m_data_type,
 			char *data,
 			int *error_return ) ;
 
diff --git a/src/cgns_header.h b/src/cgns_header.h
index c575c33f77f..493116ceb6f 100644
--- a/ThirdParty/cgns/vtkcgns/src/cgns_header.h
+++ b/ThirdParty/cgns/vtkcgns/src/cgns_header.h
@@ -31,6 +31,7 @@ typedef char char_66[66]; /* 32 + '/' + 32 + '\0' */
 #else
 typedef char char_66[33]; /* 32 + '\0' (caller's malloc compat issues) */
 #endif
+typedef char char_md[CG_MAX_GOTO_DEPTH*33+1]; /* ('/'+ 32)*MAX_GOTO_DEPTH + '\0' (FAMILY TREE) */
 typedef char const cchar_33[33];
 typedef cgsize_t cgsize6_t[6];
 typedef int cgint3_t[3];
@@ -166,7 +167,7 @@ typedef struct {            /* Descriptor_t node            */
 typedef struct {
     double id;
     char_33 name;
-    char_66 family;
+    char_md family;  /* ** FAMILY TREE ** */
 } cgns_famname;
 
 typedef struct {            /* DimensionalUnits_t Node      */
@@ -249,7 +250,7 @@ typedef struct cgns_user_data_s /* UserDefinedData_t Node       */
     CGNS_ENUMT(DataClass_t) data_class; /* Class of data                        */
     cgns_units *units;      /* ptrs to in-memory copy of units      */
     CGNS_ENUMT(GridLocation_t) location;/* Grid location where data is recorded */
-    char_66 family_name;    /* Family name              */
+    char_md family_name;    /* Family name              */            /* ** FAMILY TREE ** */
     int ordinal;            /* option to specify a rank     */
     cgns_ptset *ptset;      /* PointList, PointRange                */
     int nuser_data;         /* number of user defined data nodes    */
@@ -569,7 +570,7 @@ typedef struct {            /* BC_t node                */
     CGNS_ENUMT(GridLocation_t) location;/* Grid location                        */
     CGNS_ENUMT(BCType_t) type;          /* type of boco                         */
     cgns_ptset *ptset;      /* PointList, PointRange                */
-    char_66 family_name;    /* Family name for the bound. patch */
+    char_md family_name;    /* Family name for the bound. patch */  /* ** FAMILY TREE ** */
     int *Nindex;            /* Inward Normal Index          */
     double index_id;        /* ADF ID number of InwardNormalIndex   */
     cgns_array *normal;     /* Inward Normal List           */
@@ -647,7 +648,7 @@ typedef struct {            /* GridConnectivity1to1_t node      */
     int *transform;         /* short form of transformation matrix  */
     cgns_ptset ptset;       /* PointRange               */
     cgns_ptset dptset;      /* PointRangeDonor          */
-    char_66 donor;          /* donor name                           */
+    char_md donor;          /* donor name                           */
     int ordinal;            /* option to specify a rank     */
     int nuser_data;         /* number of user defined data nodes    */  /* V2.1 */
     cgns_user_data *user_data; /* User defined data.        */  /* V2.1 */
@@ -786,7 +787,7 @@ typedef struct {            /* ZoneSubRegion_t Node                 */
     CGNS_ENUMT(DataClass_t) data_class; /* Class of data            */
     cgns_units *units;      /* Dimensional Units                    */
     CGNS_ENUMT(GridLocation_t) location;/* Grid location where data is recorded */
-    char_66 family_name;    /* Family name                          */
+    char_md family_name;    /* Family name                          */ /* ** FAMILY TREE ** */
     int *rind_planes;       /* No. of rind-planes on each zone face */
     int nuser_data;         /* number of user defined data nodes    */
     cgns_user_data *user_data; /* User defined data.                */
@@ -809,7 +810,7 @@ typedef struct {            /* Zone_t Node              */
     cgns_zcoor *zcoor;      /* ptrs to in-memory copies of coords   */
     int nsections;          /* no of Elements_t nodes       */
     cgns_section *section;  /* ptrs to in-memory copies of section  */
-    char_66 family_name;    /* family name of the unstr. zone   */
+    char_md family_name;    /* family name of the unstr. zone   */ /* ** FAMILY TREE ** */
     int nsols;              /* number of FlowSolution_t nodes   */
     cgns_sol *sol;          /* ptrs to in-memory copies of sols */
     int ndiscrete;          /* number of DiscreteData_t nodes   */
@@ -875,7 +876,7 @@ typedef struct {            /* FamilyBC_t node          */
     cgns_dataset *dataset;  /* ptrs to in-mem. copy of BCDataSet    */
 } cgns_fambc;
 
-typedef struct {            /* Family_t node            */
+typedef struct cgns_family_s {            /* Family_t node            */
     char_33 name;           /* Family name & name of ADF node   */
     double id;              /* ADF ID number (address) of node      */
     cgns_link *link;        /* link information         */  /* V2.1 */
@@ -893,6 +894,9 @@ typedef struct {            /* Family_t node            */
 /* CPEX 0033 */
     int nfamname;
     cgns_famname *famname;
+    /* ** FAMILY TREE ** */
+    int nfamilies;
+    struct cgns_family_s* family;
 } cgns_family;
 
 typedef struct {            /* CGNSBase_t Node          */
@@ -1052,6 +1056,7 @@ cgns_model *cgi_model_address(int local_mode, char const *ModelLabel, int *ier);
 char *cgi_famname_address(int local_mode, int *ier);
 cgns_famname *cgi_multfam_address(int mode, int num, char const *name, int *ier);
 cgns_user_data *cgi_user_data_address(int local_mode, int given_no, char const *given_name, int *ier);
+cgns_family *cgi_family_address(int local_node, int given_no, char const *given_name, int *ier); /* ** FAMILY TREE ** */
 cgns_rotating *cgi_rotating_address(int local_mode, int *ier);
 cgns_ptset *cgi_ptset_address(int local_mode, int *ier);
 cgns_dataset * cgi_bcdataset_address(int local_mode, int given_no,
@@ -1066,7 +1071,7 @@ int cgi_read_family(cgns_family *family);
 int cgi_read_family_dataset(int in_link, double parent_id, int *ndataset,
                             cgns_dataset **dataset);
 int cgi_read_family_name(int in_link, double parent_id, char_33 parent_name,
-                         char_33 family_name);
+                         char_md family_name); /** FAMILY TREE **/
 int cgi_read_array(cgns_array *array, char *parent_label, double parent_id);
 int cgi_read_section(int in_link, double parent_id, int *nsections,
                      cgns_section **section);
@@ -1242,7 +1247,7 @@ int cgi_AverageInterfaceType(char *Name, CGNS_ENUMT(AverageInterfaceType_t) *typ
 
 int cgi_zone_no(cgns_base *base, char *zonename, int *zone_no);
 
-/* miscelleneous */
+/* miscellaneous */
 int cgi_sort_names(int n, double *ids);
 int size_of(const char_33 adf_type);
 char *type_of(char_33 data_type);
diff --git a/src/cgns_internals.c b/src/cgns_internals.c
index e32564397fa..14679b75cd0 100644
--- a/ThirdParty/cgns/vtkcgns/src/cgns_internals.c
+++ b/ThirdParty/cgns/vtkcgns/src/cgns_internals.c
@@ -33,13 +33,16 @@ freely, subject to the following restrictions:
 #ifdef MEM_DEBUG
 #include "cg_malloc.h"
 #endif
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
 #include "adfh/ADFH.h"
 #include "vtk_hdf5.h"
 #endif
 
 #define CGNS_NAN(x)  (!((x) < HUGE_VAL && (x) > -HUGE_VAL))
 
+/* Flag for contiguous (0) or compact storage (1) */
+extern int HDF5storage_type;
+
 /***********************************************************************
  * global variable definitions
  ***********************************************************************/
@@ -89,8 +92,8 @@ int cgi_read()
     double *id;
 
      /* get number of CGNSBase_t nodes and their ID */
-
     if (cgi_get_nodes(cg->rootid, "CGNSBase_t", &cg->nbases, &id)) return CG_ERROR;
+
     if (cg->nbases==0) return CG_OK;
     cg->base = CGNS_NEW(cgns_base,cg->nbases);
     for (b=0; b<cg->nbases; b++) cg->base[b].id = id[b];
@@ -168,7 +171,7 @@ int cgi_read_base(cgns_base *base)
         }
     }
 
-     /* Family_t */
+     /* Family_t */ /* -- FAMILY TREE -- */
     if (cgi_get_nodes(base->id, "Family_t", &base->nfamilies, &id)) return CG_ERROR;
     if (base->nfamilies>0) {
          /* read & save families */
@@ -370,11 +373,11 @@ int cgi_read_zone(cgns_zone *zone)
         return CG_ERROR;
     }
 
-     /* FamilyName_t */
+     /* FamilyName_t */ /* -- FAMILY TREE -- */
     if (cgi_read_family_name(in_link, zone->id, zone->name, zone->family_name))
         return CG_ERROR;
 
-    /* CPEX 0034 */
+    /* CPEX 0034 */ /* -- FAMILY TREE -- */
     if (cgi_get_nodes(zone->id, "AdditionalFamilyName_t", &zone->nfamname, &id))
         return CG_ERROR;
     if (zone->nfamname > 0) {
@@ -383,7 +386,7 @@ int cgi_read_zone(cgns_zone *zone)
         for (n = 0; n < zone->nfamname; n++) {
             zone->famname[n].id = id[n];
             if (cgi_read_string(id[n], zone->famname[n].name, &fam)) return CG_ERROR;
-            strncpy(zone->famname[n].family, fam, 32);
+            strncpy(zone->famname[n].family, fam, (CG_MAX_GOTO_DEPTH*(CGIO_MAX_NAME_LENGTH+1)));
             CGNS_FREE(fam);
         }
         CGNS_FREE(id);
@@ -451,7 +454,7 @@ int cgi_read_zone(cgns_zone *zone)
     return CG_OK;
 }
 
-int cgi_read_family(cgns_family *family)
+int cgi_read_family(cgns_family *family) /* ** FAMILY TREE ** */
 {
     int n, linked, in_link = family->link ? 1 : family->in_link;
     double *id;
@@ -472,7 +475,7 @@ int cgi_read_family(cgns_family *family)
         for (n = 0; n < family->nfamname; n++) {
             family->famname[n].id = id[n];
             if (cgi_read_string(id[n], family->famname[n].name, &fam)) return CG_ERROR;
-            strncpy(family->famname[n].family, fam, 32);
+            strncpy(family->famname[n].family, fam,(CG_MAX_GOTO_DEPTH*(CGIO_MAX_NAME_LENGTH+1)));
             CGNS_FREE(fam);
         }
         CGNS_FREE(id);
@@ -609,7 +612,21 @@ int cgi_read_family(cgns_family *family)
         CGNS_FREE(id);
     }
 
-     /* Ordinal_t */
+    /* Family_t */ /* ** FAMILY TREE ** */
+    if (cgi_get_nodes(family->id, "Family_t", &family->nfamilies, &id)) return CG_ERROR;
+    if (family->nfamilies>0) {
+         /* read & save families */
+        family->family = CGNS_NEW(cgns_family, family->nfamilies);
+        for (n=0; n<family->nfamilies; n++) {
+            family->family[n].id = id[n];
+            family->family[n].link = cgi_read_link(id[n]);
+            family->family[n].in_link = 0;
+            if (cgi_read_family(&family->family[n])) return CG_ERROR;
+        }
+        CGNS_FREE(id);
+    }
+
+    /* Ordinal_t */
     if (cgi_read_ordinal(family->id, &family->ordinal)) return CG_ERROR;
 
      /* UserDefinedData_t */
@@ -722,8 +739,9 @@ int cgi_read_family_dataset(int in_link, double parent_id, int *ndataset,
     return CG_OK;
 }
 
+/* ** FAMILY TREE ** */
 int cgi_read_family_name(int in_link, double parent_id, char_33 parent_name,
-                         char_33 family_name)
+                         char_md family_name)
 {
     int fam_flag;
     double *id;
@@ -738,7 +756,9 @@ int cgi_read_family_name(int in_link, double parent_id, char_33 parent_name,
 
          /* FamilyName in data field of the ADF node */
             if (cgi_read_string(id[0], NodeName, &FamilyName)) return CG_ERROR;
-            if (strlen(FamilyName) > 32) FamilyName[32]='\0';
+            if (strlen(FamilyName) > (CG_MAX_GOTO_DEPTH*(CGIO_MAX_NAME_LENGTH+1))) {
+                FamilyName[(CG_MAX_GOTO_DEPTH*(CGIO_MAX_NAME_LENGTH+1))]='\0'; /* ** FAMILY TREE ** */
+            }
             strcpy(family_name, FamilyName);
             if (FamilyName) CGNS_FREE(FamilyName);
 
@@ -1410,8 +1430,8 @@ int cgi_read_section(int in_link, double parent_id, int *nsections,
 		cgi_error("malloc failed for ParentData conversion array");
 		return CG_ERROR;
 	    }
-	    if (cgio_read_all_data(cg->cgio, section[0][n].parelem->id, pardata)) {
-                cg_io_error("cgio_read_all_data");
+	    if (cgio_read_all_data_type(cg->cgio, section[0][n].parelem->id, data_type, pardata)) {
+                cg_io_error("cgio_read_all_data_type");
 		return CG_ERROR;
 	    }
 	    if (cgi_delete_node(section[0][n].id, section[0][n].parelem->id))
@@ -1706,7 +1726,7 @@ int cgi_read_1to1(cgns_1to1 *one21)
         return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
     /*
      * Convert the double id to a hid_t id and compare that to 0 instead of
@@ -1883,7 +1903,7 @@ int cgi_read_conn(cgns_conn *conn)
         return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(conn->ptset.id, hid);
@@ -2450,7 +2470,7 @@ int cgi_read_boco(cgns_boco *boco)
     }
 #endif
 
-     /* FamilyName_t */
+     /* FamilyName_t */ /* -- FAMILY TREE -- */
     if (cgi_read_family_name(linked, boco->id, boco->name, boco->family_name))
         return CG_ERROR;
 
@@ -2463,7 +2483,7 @@ int cgi_read_boco(cgns_boco *boco)
         for (n = 0; n < boco->nfamname; n++) {
             boco->famname[n].id = id[n];
             if (cgi_read_string(id[n], boco->famname[n].name, &fam)) return CG_ERROR;
-            strncpy(boco->famname[n].family, fam, 32);
+            strncpy(boco->famname[n].family, fam, (CG_MAX_GOTO_DEPTH*(CGIO_MAX_NAME_LENGTH+1)));
             CGNS_FREE(fam);
         }
         CGNS_FREE(id);
@@ -3012,6 +3032,7 @@ int cgi_read_one_ptset(int linked, double parent_id, cgns_ptset **pptset)
             continue;
         if (ptset != NULL) {
             cgi_error("Multiple definitions of PointList/PointRange");
+            CGNS_FREE(ptset);
             return CG_ERROR;
         }
         ptset = CGNS_NEW(cgns_ptset, 1);
@@ -3022,7 +3043,10 @@ int cgi_read_one_ptset(int linked, double parent_id, cgns_ptset **pptset)
         ptset->id=I_id[i];
         ptset->link=cgi_read_link(I_id[i]);
         ptset->in_link=linked;
-        if (cgi_read_ptset(I_id[i], ptset)) return CG_ERROR;
+        if (cgi_read_ptset(I_id[i], ptset)){
+            CGNS_FREE(ptset);
+            return CG_ERROR;
+        }
     }
     if (nI_t) CGNS_FREE(I_id);
 
@@ -3037,6 +3061,7 @@ int cgi_read_one_ptset(int linked, double parent_id, cgns_ptset **pptset)
             continue;
         if (ptset != NULL) {
             cgi_error("Multiple definitions of PointList/PointRange");
+            CGNS_FREE(ptset);
             return CG_ERROR;
         }
         ptset = CGNS_NEW(cgns_ptset, 1);
@@ -3047,7 +3072,10 @@ int cgi_read_one_ptset(int linked, double parent_id, cgns_ptset **pptset)
         ptset->id=I_id[i];
         ptset->link=cgi_read_link(I_id[i]);
         ptset->in_link=linked;
-        if (cgi_read_ptset(I_id[i], ptset)) return CG_ERROR;
+        if (cgi_read_ptset(I_id[i], ptset)){
+            CGNS_FREE(ptset);
+            return CG_ERROR;
+        }
     }
     if (nI_t) CGNS_FREE(I_id);
 
@@ -3111,7 +3139,8 @@ int cgi_read_ptset(double parent_id, cgns_ptset *ptset)
      /* size_of_patch */
     if (ptset->type == CGNS_ENUMV(PointList) ||
         ptset->type == CGNS_ENUMV(ElementList) ||
-        ptset->type == CGNS_ENUMV(PointListDonor)) {
+        ptset->type == CGNS_ENUMV(PointListDonor) ||
+        ptset->type == CGNS_ENUMV(CellListDonor)) {
         ptset->size_of_patch = ptset->npts;
     }
     else {
@@ -3126,8 +3155,8 @@ int cgi_read_ptset(double parent_id, cgns_ptset *ptset)
         if (0 == strcmp(ptset->data_type,"I8")) {
             cglong_t total = 1;
             cglong_t *pnts = CGNS_NEW(cglong_t, size);
-            if (cgio_read_all_data(cg->cgio, ptset->id, pnts)) {
-                cg_io_error("cgio_read_all_data");
+            if (cgio_read_all_data_type(cg->cgio, ptset->id, ptset->data_type, pnts)) {
+                cg_io_error("cgio_read_all_data_type");
                 return CG_ERROR;
             }
 #if CG_SIZEOF_SIZE == 32
@@ -3148,8 +3177,8 @@ int cgi_read_ptset(double parent_id, cgns_ptset *ptset)
         }
         else if (0 == strcmp(ptset->data_type,"I4")) {
             int *pnts = CGNS_NEW(int, size);
-            if (cgio_read_all_data(cg->cgio, ptset->id, pnts)) {
-                cg_io_error("cgio_read_all_data");
+            if (cgio_read_all_data_type(cg->cgio, ptset->id, ptset->data_type, pnts)) {
+                cg_io_error("cgio_read_all_data_type");
                 return CG_ERROR;
             }
             ptset->size_of_patch = 1;
@@ -4444,7 +4473,7 @@ int cgi_read_exponents(int in_link, double parent_id, cgns_exponent **exponents)
                              &data, READ_DATA);
         CGNS_FREE(id);
         if (ierr) {
-            cgi_error("Error reading AdditionalExponents for 's'",
+            cgi_error("Error reading AdditionalExponents for '%s'",
                 exponents[0]->name);
             return CG_ERROR;
         }
@@ -5074,7 +5103,7 @@ int cgi_read_user_data(int in_link, double parent_id, int *nuser_data,
         if (cgi_read_location(user_data[0][n].id, user_data[0][n].name,
             &user_data[0][n].location)) return CG_ERROR;
 
-     /* FamilyName_t */
+     /* FamilyName_t */ /* -- FAMILY TREE -- */
         if (cgi_read_family_name(linked, user_data[0][n].id,
                                  user_data[0][n].name,
                                  user_data[0][n].family_name))
@@ -5091,7 +5120,7 @@ int cgi_read_user_data(int in_link, double parent_id, int *nuser_data,
                 user_data[0][n].famname[i].id = idi[i];
                 if (cgi_read_string(idi[i], user_data[0][n].famname[i].name,
                         &fam)) return CG_ERROR;
-                strncpy(user_data[0][n].famname[i].family, fam, 32);
+                strncpy(user_data[0][n].famname[i].family, fam, (CG_MAX_GOTO_DEPTH*33));
                 CGNS_FREE(fam);
             }
             CGNS_FREE(idi);
@@ -5299,7 +5328,7 @@ int cgi_read_subregion(int in_link, double parent_id, int *nsubreg,
         if (cgi_read_location(reg[n].id, reg[n].name,
             &reg[n].location)) return CG_ERROR;
 
-        /* FamilyName_t */
+        /* FamilyName_t */ /* -- FAMILY TREE -- */
         if (cgi_read_family_name(linked, reg[n].id,
                 reg[n].name, reg[n].family_name))
             return CG_ERROR;
@@ -5313,7 +5342,7 @@ int cgi_read_subregion(int in_link, double parent_id, int *nsubreg,
             for (i = 0; i < reg[n].nfamname; i++) {
                 reg[n].famname[i].id = idi[i];
                 if (cgi_read_string(idi[i], reg[n].famname[i].name, &fam)) return CG_ERROR;
-                strncpy(reg[n].famname[i].family, fam, 32);
+                strncpy(reg[n].famname[i].family, fam, (20*33)-1);
                 CGNS_FREE(fam);
             }
             CGNS_FREE(idi);
@@ -5431,8 +5460,8 @@ int cgi_read_node(double node_id, char_33 name, char_33 data_type,
     else if (strcmp(data_type,"C1")==0) data[0]=CGNS_NEW(char, size+1);
 
      /* read data */
-    if (cgio_read_all_data(cg->cgio, node_id, data[0])) {
-        cg_io_error("cgio_read_all_data");
+    if (cgio_read_all_data_type(cg->cgio, node_id, data_type, data[0])) {
+        cg_io_error("cgio_read_all_data_type");
         return CG_ERROR;
     }
     return CG_OK;
@@ -5555,8 +5584,8 @@ int cgi_read_int_data(double id, char_33 data_type, cgsize_t cnt, cgsize_t *data
             cgi_error("Error allocating I4->I8 data array...");
             return CG_ERROR;
         }
-        if (cgio_read_all_data(cg->cgio, id, (void *)pnts)) {
-            cg_io_error("cgio_read_all_data");
+        if (cgio_read_all_data_type(cg->cgio, id, data_type,(void *)pnts)) {
+            cg_io_error("cgio_read_all_data_type");
             CGNS_FREE(pnts);
             return CG_ERROR;
         }
@@ -5571,8 +5600,8 @@ int cgi_read_int_data(double id, char_33 data_type, cgsize_t cnt, cgsize_t *data
             cgi_error("Error allocating I8->I4 data array...");
             return CG_ERROR;
         }
-        if (cgio_read_all_data(cg->cgio, id, (void *)pnts)) {
-            cg_io_error("cgio_read_all_data");
+        if (cgio_read_all_data_type(cg->cgio, id, data_type, (void *)pnts)) {
+            cg_io_error("cgio_read_all_data_type");
             CGNS_FREE(pnts);
             return CG_ERROR;
         }
@@ -5582,8 +5611,8 @@ int cgi_read_int_data(double id, char_33 data_type, cgsize_t cnt, cgsize_t *data
     }
 #endif
     else {
-        if (cgio_read_all_data(cg->cgio, id, (void *)data)) {
-            cg_io_error("cgio_read_all_data");
+        if (cgio_read_all_data_type(cg->cgio, id, data_type, (void *)data)) {
+            cg_io_error("cgio_read_all_data_type");
             return CG_ERROR;
         }
     }
@@ -6024,7 +6053,7 @@ int cgi_write_zone(double parent_id, cgns_zone *zone)
     return CG_OK;
 }
 
-int cgi_write_family(double parent_id, cgns_family *family)
+int cgi_write_family(double parent_id, cgns_family *family) /* ** FAMILY TREE ** */
 {
     int n;
     cgsize_t dim_vals;
@@ -6122,6 +6151,11 @@ int cgi_write_family(double parent_id, cgns_family *family)
     if (family->rotating && cgi_write_rotating(family->id, family->rotating))
         return CG_ERROR;
 
+    /* ** FAMILY TREE ** */
+    for( n = 0; n < family->nfamilies; n++ ) {
+        if (cgi_write_family(family->id, &family->family[n])) return CG_ERROR;
+    }
+
     return CG_OK;
 }
 
@@ -6131,6 +6165,8 @@ int cgi_write_section(double parent_id, cgns_section *section)
     cgsize_t dim_vals;
     double dummy_id;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
     if (section->link) {
         return cgi_write_link(parent_id, section->name,
             section->link, &section->id);
@@ -6169,6 +6205,7 @@ int cgi_write_section(double parent_id, cgns_section *section)
     for (n=0; n<section->nuser_data; n++)
         if (cgi_write_user_data(section->id, &section->user_data[n])) return CG_ERROR;
 
+    HDF5storage_type = CG_COMPACT;
     return CG_OK;
 }
 
@@ -6349,6 +6386,8 @@ int cgi_write_conns(double parent_id, cgns_conn *conn)
     double dummy_id;
     cgns_ptset *ptset;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
     if (conn->link) {
         return cgi_write_link(parent_id, conn->name,
             conn->link, &conn->id);
@@ -6405,6 +6444,8 @@ int cgi_write_conns(double parent_id, cgns_conn *conn)
     for (n=0; n<conn->nuser_data; n++)
         if (cgi_write_user_data(conn->id, &conn->user_data[n])) return CG_ERROR;
 
+    HDF5storage_type = CG_COMPACT;
+
     return CG_OK;
 }
 
@@ -7510,6 +7551,8 @@ int cgi_write_array(double parent_id, cgns_array *array)
     cgsize_t dim_vals;
     double dummy_id;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
     if (array->link) {
         return cgi_write_link(parent_id, array->name,
             array->link, &array->id);
@@ -7550,6 +7593,8 @@ int cgi_write_array(double parent_id, cgns_array *array)
                          &dummy_id, "I4", 1, &dim_vals, array->range))
             return CG_ERROR;
 
+    HDF5storage_type = CG_COMPACT;
+
     return CG_OK;
 }
 
@@ -7952,13 +7997,14 @@ int cgi_array_general_verify_range(
     cgsize_t *numpt)                    /* [O] number of points accessed */
 {
     cgsize_t s_numpt = 1, m_numpt = 1;
-    int n, npt;
+    cgsize_t npt;
+    int n;
 
     int s_reset_range = 1;
     *s_access_full_range = 1;
     *m_access_full_range = 1;
 
-     /*** verfication for dataset in file */
+     /*** verification for dataset in file */
      /* verify that range requested is not NULL */
     if (rmin == NULL || rmax == NULL) {
         cgi_error("NULL range value");
@@ -7996,7 +8042,7 @@ int cgi_array_general_verify_range(
                 }
             }
             else {
-                /* new behavior consitent with SIDS */
+                /* new behavior consistent with SIDS */
                 if (rmin[n] > rmax[n] ||
                     rmax[n] > (s_dimvals[n] - rind_planes[2*n]) ||
                     rmin[n] < (1 - rind_planes[2*n])) {
@@ -8130,20 +8176,19 @@ int cgi_array_general_read(
     if (ier != CG_OK) return ier;
     const int access_full_range =
         (s_access_full_range == 1) && (m_access_full_range == 1);
-
     if (s_type == m_type) {
          /* quick transfer of data if same data types */
         if (access_full_range) {
-            if (cgio_read_all_data(cg->cgio, array->id, data)) {
-                cg_io_error("cgio_read_all_data");
+            if (cgio_read_all_data_type(cg->cgio, array->id, cgi_adf_datatype(m_type), data)) {
+                cg_io_error("cgio_read_all_data_type");
                 return CG_ERROR;
             }
         }
         else {
-            if (cgio_read_data(cg->cgio, array->id,
-                               s_rmin, s_rmax, stride, m_numdim, m_dimvals,
+            if (cgio_read_data_type(cg->cgio, array->id,
+                               s_rmin, s_rmax, stride, cgi_adf_datatype(m_type), m_numdim, m_dimvals,
                                m_rmin, m_rmax, stride, data)) {
-                cg_io_error("cgio_read_data");
+                cg_io_error("cgio_read_data_type");
                 return CG_ERROR;
             }
         }
@@ -8163,18 +8208,18 @@ int cgi_array_general_read(
             return CG_ERROR;
         }
         if (access_full_range) {
-            if (cgio_read_all_data(cg->cgio, array->id, conv_data)) {
+            if (cgio_read_all_data_type(cg->cgio, array->id, array->data_type, conv_data)) {
                 free(conv_data);
-                cg_io_error("cgio_read_all_data");
+                cg_io_error("cgio_read_all_data_type");
                 return CG_ERROR;
             }
         }
         else {
-            if (cgio_read_data(cg->cgio, array->id, s_rmin, s_rmax, stride,
-                               m_numdim, m_dimvals, m_rmin, m_rmax, stride,
-                               conv_data)) {
+            if (cgio_read_data_type(cg->cgio, array->id, s_rmin, s_rmax, stride,
+                                    array->data_type,
+                                    m_numdim, m_dimvals, m_rmin, m_rmax, stride, conv_data)) {
                 free(conv_data);
-                cg_io_error("cgio_read_data");
+                cg_io_error("cgio_read_data_type");
                return CG_ERROR;
             }
         }
@@ -8587,7 +8632,8 @@ int cgi_check_strlen(char const *string)
 
 int cgi_check_strlen_x2(char const *string)
 {
-    int n1,n2,p;
+    int n1,n2;
+    size_t p;
 
     if (strlen(string) > 65) {
         cgi_error("Name exceeds 65 characters limit: %s",string);
@@ -8654,11 +8700,10 @@ int cgi_add_czone(char_33 zonename, cgsize6_t range, cgsize6_t donor_range,
 
      /* check if this interface was already found */
     for (k=0; k<(*ndouble); k++) {
-        differ=0;
         if (strcmp(Dzonename[0][k],zonename)) {
-            differ=1;
             continue;
         }
+        differ=0;
         for (j=0; j<index_dim; j++) {
             if (Drange[0][k][j]==Drange[0][k][j+index_dim]) continue;
             if (Drange[0][k][j]!=MIN(donor_range[j],donor_range[j+index_dim]) ||
@@ -10498,6 +10543,22 @@ static int cgi_next_posit(char *label, int index, char *name)
                            label, index + 1, f->user_data[index].id);
             }
         }
+        /* ** FAMILY TREE ** */
+        else if (0 == strcmp (label, "Family_t")) {
+            if (--index < 0) {
+                for (n = 0; n < f->nfamilies; n++) {
+                    if (0 == strcmp (f->family[n].name, name)) {
+                        index = n;
+                        break;
+                    }
+                }
+            }
+
+            if (index >= 0 && index < f->nfamilies) {
+                return cgi_add_posit((void *)&f->family[index],
+                           label, index + 1, f->family[index].id);
+            }
+        }
         else
             return CG_INCORRECT_PATH;
     }
@@ -10529,7 +10590,7 @@ static int cgi_next_posit(char *label, int index, char *name)
     else if (0 == strcmp (posit->label, "FamilyBC_t")) {
         cgns_fambc *f = (cgns_fambc *)posit->posit;
         if (0 == strcmp (label, "FamilyBCDataSet_t") ||
-            /* backwards compatibily */
+            /* backwards compatibility */
             0 == strcmp (label, "BCDataSet_t")) {
             if (--index < 0) {
                 for (n = 0; n < f->ndataset; n++) {
@@ -11278,7 +11339,7 @@ cgns_descr *cgi_descr_address(int local_mode, int given_no,
         ADDRESS4MULTIPLE(cgns_state, ndescr, descr, cgns_descr)
     else if (strcmp(posit->label,"DataArray_t")==0)
         ADDRESS4MULTIPLE(cgns_array, ndescr, descr, cgns_descr)
-    else if (strcmp(posit->label,"Family_t")==0)
+    else if (strcmp(posit->label,"Family_t")==0)/* -- FAMILY TREE -- */
         ADDRESS4MULTIPLE(cgns_family, ndescr, descr, cgns_descr)
     else if (strcmp(posit->label,"GeometryReference_t")==0)
         ADDRESS4MULTIPLE(cgns_geo, ndescr, descr, cgns_descr)
@@ -11379,7 +11440,7 @@ char *cgi_famname_address(int local_mode, int *ier)
         return CG_OK;
     }
     if (cg->mode == CG_MODE_MODIFY && local_mode == CG_MODE_WRITE) {
-        if (cgi_get_nodes(parent_id, "FamilyName_t", &nnod, &id)) {
+        if (cgi_get_nodes(parent_id, "FamilyName_t", &nnod, &id)) {/* -- FAMILY TREE -- */
             *ier = CG_ERROR;
             return CG_OK;
         }
@@ -11414,6 +11475,8 @@ cgns_famname *cgi_multfam_address(int local_mode, int given_no,
         ADDRESS4MULTIPLE(cgns_subreg, nfamname, famname, cgns_famname)
     else if (0 == strcmp(posit->label, "UserDefinedData_t"))
         ADDRESS4MULTIPLE(cgns_user_data, nfamname, famname, cgns_famname)
+    else if (0 == strcmp(posit->label, "Family_t")) /* ** FAMILY TREE ** */
+        ADDRESS4MULTIPLE(cgns_family, nfamname, famname, cgns_famname)
     else {
         cgi_error("AdditionalFamilyName_t node not supported under '%s' type node",posit->label);
         (*ier) = CG_INCORRECT_PATH;
@@ -11709,7 +11772,7 @@ int *cgi_rind_address(int local_mode, int *ier)
 {
     int *rind_planes=0, nnod;
     double parent_id=0, *id;
-    int error1=0, index_dim;
+    int error1, index_dim;
 
     /* check for valid posit */
     if (posit == 0) {
@@ -11749,6 +11812,7 @@ int *cgi_rind_address(int local_mode, int *ier)
     }
 
 /* Corrected on July 27 2001 by Diane Poirier
+    
     if (error1==1) {
         cgi_error("Rind_t already defined under %s",posit->label);
         (*ier) = CG_ERROR;
@@ -12678,6 +12742,56 @@ cgns_user_data *cgi_user_data_address(int local_mode, int given_no,
     return user_data;
 }
 
+/* ** FAMILY TREE ** */
+cgns_family *cgi_family_address(int local_mode, int given_no,
+                                char const *given_name, int *ier)
+{
+    cgns_family *family=0;
+    int n, allow_dup=0, error1=0, error2=0;
+    double parent_id=0;
+
+    /* check for valid posit */
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        (*ier) = CG_ERROR;
+        return CG_OK;
+    }
+
+/* Possible parents of Family_t node:
+ *  Family_t, CGNSBase_t
+ */
+
+    if (strcmp(posit->label,"Family_t")==0)
+        ADDRESS4MULTIPLE(cgns_family, nfamilies, family, cgns_family)
+    else if (strcmp(posit->label,"CGNSBase_t")==0)
+        ADDRESS4MULTIPLE(cgns_base, nfamilies, family, cgns_family)
+    else {
+        cgi_error("Family_t node not supported under '%s' type node",posit->label);
+        (*ier) = CG_INCORRECT_PATH;
+        return CG_OK;
+    }
+    if (error1) {
+        cgi_error("Duplicate child name found (%s) found under %s",
+            given_name, posit->label);
+        (*ier) = CG_ERROR;
+        return CG_OK;
+    }
+    if (error2) {
+        cgi_error("UserDefinedData index number %d doesn't exist under %s",
+            given_no, posit->label);
+        (*ier) = CG_NODE_NOT_FOUND;
+        return CG_OK;
+    }
+    if (parent_id) {     /* parent_id!=0 only when overwriting */
+        if (cgi_delete_node (parent_id, family->id)) {
+            (*ier) = CG_ERROR;
+            return CG_OK;
+        }
+        cgi_free_family(family);
+    }
+    return family;
+}
+
 cgns_rotating *cgi_rotating_address(int local_mode, int *ier)
 {
     cgns_rotating *rotating=0;
@@ -13052,7 +13166,7 @@ void cgi_free_section(cgns_section *section)
     }
 }
 
-void cgi_free_family(cgns_family *family)
+void cgi_free_family(cgns_family *family) /* ** FAMILY TREE ** */
 {
     int n;
     if (family->link) CGNS_FREE(family->link);
@@ -13071,6 +13185,14 @@ void cgi_free_family(cgns_family *family)
             cgi_free_geo(&family->geo[n]);
         CGNS_FREE(family->geo);
     }
+
+    /* FAMILY TREE : Free Family_t nodes */
+    if ( family->nfamilies ) {
+        for( n = 0; n < family->nfamilies; n++ )
+            cgi_free_family( &family->family[n] );
+        CGNS_FREE( family->family );
+    }
+
     if (family->nuser_data) {
         for (n=0; n<family->nuser_data; n++)
             cgi_free_user_data(&family->user_data[n]);
diff --git a/src/cgns_io.c b/src/cgns_io.c
index a317bcf517b..b939805f1c2 100644
--- a/ThirdParty/cgns/vtkcgns/src/cgns_io.c
+++ b/ThirdParty/cgns/vtkcgns/src/cgns_io.c
@@ -43,16 +43,16 @@ freely, subject to the following restrictions:
 #include "cgns_io.h"
 #include "cgnslib.h"
 #include "adf/ADF.h"
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
 #include "adfh/ADFH.h"
 char hdf5_access[64] = "NATIVE";
 #endif
 #ifdef MEM_DEBUG
 #include "cg_malloc.h"
 #endif
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
 #include <mpi.h>
-MPI_Comm pcg_mpi_comm=MPI_COMM_WORLD;
+MPI_Comm pcg_mpi_comm=MPI_COMM_NULL;
 int pcg_mpi_comm_size;
 int pcg_mpi_comm_rank;
 int pcg_mpi_initialized;
@@ -67,6 +67,8 @@ MPI_Info pcg_mpi_info;
 #endif
 #endif
 
+/* Flag for contiguous or compact HDF5 storage */
+extern int HDF5storage_type;
 
 typedef struct {
     int type;
@@ -99,7 +101,7 @@ static char *cgio_ErrorMessage[] = {
     "file has the wrong specified type",
     "not a HDF5 file - required for parallel"
 };
-#define CGIO_MAX_ERRORS (sizeof(cgio_ErrorMessage)/sizeof(char *))
+#define CGIO_MAX_ERRORS ((int)(sizeof(cgio_ErrorMessage)/sizeof(char *)))
 
 #define get_error()  last_err
 
@@ -411,7 +413,7 @@ int cgio_find_file (const char *parentfile, const char *filename,
 
     if (file_type == CGIO_FILE_ADF || file_type == CGIO_FILE_ADF2)
         p = getenv ("ADF_LINK_PATH");
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (file_type == CGIO_FILE_HDF5)
         p = getenv ("HDF5_LINK_PATH");
 #endif
@@ -523,7 +525,7 @@ int cgio_is_supported (int file_type)
     if (file_type == CGIO_FILE_ADF2)
         return set_error(CGIO_ERR_NONE);
 #endif
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     if (file_type == CGIO_FILE_HDF5)
         return set_error(CGIO_ERR_NONE);
 #endif
@@ -538,7 +540,7 @@ int cgio_configure (int what, void *value)
     int ierr = CGIO_ERR_BAD_OPTION;
 
     if (what > 200) {
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
         ADFH_Configure(what-200, value, &ierr);
 #endif
     }
@@ -587,7 +589,7 @@ int cgio_check_file (const char *filename, int *file_type)
     *file_type = CGIO_FILE_NONE;
 
 
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
     /* don't overload the file system by having all the processors doing a read */
     if(pcg_mpi_comm_rank == 0) {
 #endif
@@ -601,7 +603,9 @@ int cgio_check_file (const char *filename, int *file_type)
 	}
 	return err;
       }
-    fread (buf, 1, sizeof(buf), fp);
+    if (sizeof(buf) != fread (buf, 1, sizeof(buf), fp)) {
+      buf[4] = 0;
+    }
     buf[sizeof(buf)-1] = 0;
     fclose (fp);
 
@@ -619,7 +623,7 @@ int cgio_check_file (const char *filename, int *file_type)
 	err = set_error(CGIO_ERR_NONE);
       }
     }
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
     }
     if(pcg_mpi_initialized) {
       mpibuf[0] = err;
@@ -717,7 +721,7 @@ int cgio_open_file (const char *filename, int file_mode,
         case 'R':
             if (cgio_check_file(filename, &type))
                 return get_error();
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
            if (file_type == CGIO_FILE_HDF5) {
                 if (type != CGIO_FILE_HDF5)
                     return set_error(CGIO_ERR_NOT_HDF5);
@@ -741,7 +745,7 @@ int cgio_open_file (const char *filename, int file_mode,
         case 'M':
             if (cgio_check_file(filename, &type))
                 return get_error();
-#ifdef BUILD_PARALLEL
+#if CG_BUILD_PARALLEL
            if (file_type == CGIO_FILE_HDF5) {
                 if (type != CGIO_FILE_HDF5)
                     return set_error(CGIO_ERR_NOT_HDF5);
@@ -771,7 +775,7 @@ int cgio_open_file (const char *filename, int file_mode,
         if (ierr > 0) return set_error(ierr);
     }
 #endif
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (file_type == CGIO_FILE_HDF5) {
         ADFH_Database_Open(filename, fmode, hdf5_access, &rootid, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -826,7 +830,7 @@ int cgio_close_file (int cgio_num)
         ADF_Database_Close(cgio->rootid, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Database_Close(cgio->rootid, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -861,7 +865,7 @@ int cgio_compress_file (int cgio_num, const char *filename)
             return set_error(ierr);
         }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         if (rewrite_file (cgio_num, filename)) {
             ierr = get_error();
@@ -911,7 +915,7 @@ int cgio_flush_to_disk (int cgio_num)
         ADF_Flush_to_Disk(cgio->rootid, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Flush_to_Disk(cgio->rootid, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -940,7 +944,7 @@ int cgio_library_version (int cgio_num, char *version)
         ADF_Library_Version(version, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Library_Version(version, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -969,7 +973,7 @@ int cgio_file_version (int cgio_num, char *file_version,
             creation_date, modified_date, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Database_Version(cgio->rootid, file_version,
             creation_date, modified_date, &ierr);
@@ -1038,7 +1042,7 @@ int cgio_error_message (char *error_msg)
     else if (last_type == CGIO_FILE_ADF || last_type == CGIO_FILE_ADF2) {
         ADF_Error_Message(last_err, msg);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (last_type == CGIO_FILE_HDF5) {
         ADFH_Error_Message(last_err, msg);
     }
@@ -1091,7 +1095,7 @@ int cgio_create_node (int cgio_num, double pid,
         ADF_Create(pid, name, id, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Create(pid, name, id, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1108,7 +1112,7 @@ int cgio_create_node (int cgio_num, double pid,
 
 int cgio_new_node (int cgio_num, double pid, const char *name,
     const char *label, const char *data_type, int ndims,
-    const cgsize_t *dims, const void *data, double *id)
+                   const cgsize_t *dims, const void *data, double *id)
 {
     int ierr;
     cgns_io *cgio;
@@ -1122,7 +1126,7 @@ int cgio_new_node (int cgio_num, double pid, const char *name,
         ADF_Set_Label(*id, label, &ierr);
         if (ierr > 0) return set_error(ierr);
         if (data_type != NULL && strcmp(data_type, "MT")) {
-            ADF_Put_Dimension_Information(*id, data_type, ndims, dims, &ierr);
+          ADF_Put_Dimension_Information(*id, data_type, ndims, dims, &ierr);
             if (ierr > 0) return set_error(ierr);
             if (data != NULL) {
                 ADF_Write_All_Data(*id, (const char *)data, &ierr);
@@ -1130,20 +1134,20 @@ int cgio_new_node (int cgio_num, double pid, const char *name,
             }
         }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
-        ADFH_Create(pid, name, id, &ierr);
-        if (ierr > 0) return set_error(ierr);
-        ADFH_Set_Label(*id, label, &ierr);
-        if (ierr > 0) return set_error(ierr);
-        if (data_type != NULL && strcmp(data_type, "MT")) {
-            ADFH_Put_Dimension_Information(*id, data_type, ndims, dims, &ierr);
-            if (ierr > 0) return set_error(ierr);
-            if (data != NULL) {
-                ADFH_Write_All_Data(*id, NULL, (const char *)data, &ierr);
-                if (ierr > 0) return set_error(ierr);
-            }
+      ADFH_Create(pid, name, id, &ierr);
+      if (ierr > 0) return set_error(ierr);
+      ADFH_Set_Label(*id, label, &ierr);
+      if (ierr > 0) return set_error(ierr);
+      if (data_type != NULL && strcmp(data_type, "MT")) {
+        ADFH_Put_Dimension_Information(*id, data_type, ndims, dims, HDF5storage_type, &ierr);
+        if (ierr > 0) return set_error(ierr);
+        if (data != NULL) {
+          ADFH_Write_All_Data(*id, NULL, (const char *)data, &ierr);
+          if (ierr > 0) return set_error(ierr);
         }
+      }
     }
 #endif
     else {
@@ -1167,7 +1171,7 @@ int cgio_delete_node (int cgio_num, double pid, double id)
         ADF_Delete(pid, id, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Delete(pid, id, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1195,7 +1199,7 @@ int cgio_move_node (int cgio_num, double pid, double id,
         ADF_Move_Child(pid, id, new_pid, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Move_Child(pid, id, new_pid, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1242,7 +1246,7 @@ int cgio_copy_node (int cgio_num_inp, double id_inp,
             if (data_size) {
                 data = malloc((size_t)data_size);
                 if (data == NULL) return set_error(CGIO_ERR_MALLOC);
-                ADF_Read_All_Data(id_inp, (char *)data, &ierr);
+                ADF_Read_All_Data(id_inp, data_type, (char *)data, &ierr);
                 if (ierr > 0) {
                     free(data);
                     return set_error(ierr);
@@ -1250,7 +1254,7 @@ int cgio_copy_node (int cgio_num_inp, double id_inp,
             }
         }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (input->type == CGIO_FILE_HDF5) {
         ADFH_Get_Label(id_inp, label, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1292,12 +1296,12 @@ int cgio_copy_node (int cgio_num_inp, double id_inp,
         if (data_size) free(data);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (output->type == CGIO_FILE_HDF5) {
         ADFH_Set_Label(id_out, label, &ierr);
         if (ierr <= 0) {
             ADFH_Put_Dimension_Information(id_out, data_type, ndims,
-                dims, &ierr);
+                                           dims, HDF5storage_type, &ierr);
             if (ierr <= 0 && data_size)
                 ADFH_Write_All_Data(id_out, NULL, (const char *)data, &ierr);
         }
@@ -1317,7 +1321,7 @@ int cgio_copy_node (int cgio_num_inp, double id_inp,
 
 int cgio_release_id (int cgio_num, double id)
 {
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     cgns_io *cgio;
 
     if ((cgio = get_cgnsio(cgio_num, 0)) == NULL)
@@ -1346,7 +1350,7 @@ int cgio_is_link (int cgio_num, double id, int *link_len)
         ADF_Is_Link(id, link_len, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Is_Link(id, link_len, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1374,7 +1378,7 @@ int cgio_link_size (int cgio_num, double id, int *file_len,
         ADF_Link_Size(id, file_len, name_len, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Link_Size(id, file_len, name_len, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1402,7 +1406,7 @@ int cgio_create_link (int cgio_num, double pid, const char *name,
         ADF_Link(pid, name, filename, name_in_file, id, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Link(pid, name, filename, name_in_file, id, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1430,7 +1434,7 @@ int cgio_get_link (int cgio_num, double id,
         ADF_Get_Link_Path(id, filename, name_in_file, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Get_Link_Path(id, filename, name_in_file, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1460,7 +1464,7 @@ int cgio_number_children (int cgio_num, double id,
         ADF_Number_of_Children(id, num_children, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Number_of_Children(id, num_children, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1488,7 +1492,7 @@ int cgio_children_ids (int cgio_num, double pid,
         ADF_Children_IDs(pid, start, max_ret, num_ret, ids, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Children_IDs(pid, start, max_ret, num_ret, ids, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1517,7 +1521,7 @@ int cgio_children_names (int cgio_num, double pid, int start, int max_ret,
             num_ret, names, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Children_Names(pid, start, max_ret, name_len,
             num_ret, names, &ierr);
@@ -1548,7 +1552,7 @@ int cgio_get_node_id (int cgio_num, double pid,
         ADF_Get_Node_ID(pid, name, id, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Get_Node_ID(pid, name, id, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1575,7 +1579,7 @@ int cgio_get_name (int cgio_num, double id, char *name)
         ADF_Get_Name(id, name, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Get_Name(id, name, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1602,7 +1606,7 @@ int cgio_get_label (int cgio_num, double id, char *label)
         ADF_Get_Label(id, label, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Get_Label(id, label, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1629,7 +1633,7 @@ int cgio_get_data_type (int cgio_num, double id, char *data_type)
         ADF_Get_Data_Type(id, data_type, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Get_Data_Type(id, data_type, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1678,7 +1682,7 @@ int cgio_get_dimensions (int cgio_num, double id,
         }
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Get_Number_of_Dimensions(id, num_dims, &ierr);
         if (NULL != dims && ierr <= 0 && *num_dims > 0) {
@@ -1696,33 +1700,6 @@ int cgio_get_dimensions (int cgio_num, double id,
 
 /*---------------------------------------------------------*/
 
-int cgio_read_all_data (int cgio_num, double id, void *data)
-{
-    int ierr;
-    cgns_io *cgio;
-
-    if ((cgio = get_cgnsio(cgio_num, 0)) == NULL)
-        return get_error();
-
-    if (cgio->type == CGIO_FILE_ADF || cgio->type == CGIO_FILE_ADF2) {
-        ADF_Read_All_Data(id, (char *)data, &ierr);
-        if (ierr > 0) return set_error(ierr);
-    }
-#ifdef BUILD_HDF5
-    else if (cgio->type == CGIO_FILE_HDF5) {
-        ADFH_Read_All_Data(id, NULL, (char *)data, &ierr);
-        if (ierr > 0) return set_error(ierr);
-    }
-#endif
-    else {
-        return set_error(CGIO_ERR_FILE_TYPE);
-    }
-
-    return CGIO_ERR_NONE;
-}
-
-/*---------------------------------------------------------*/
-
 int cgio_read_all_data_type (int cgio_num, double id, const char *m_data_type,
     void *data)
 {
@@ -1733,41 +1710,15 @@ int cgio_read_all_data_type (int cgio_num, double id, const char *m_data_type,
         return get_error();
 
     if (cgio->type == CGIO_FILE_ADF || cgio->type == CGIO_FILE_ADF2) {
-         /* Changing type when reading is not supported with adf files.  In
-            practice, we convert first and call cgio_read_all_data */
-        return set_error(CGIO_ERR_NOT_HDF5);
-    }
-#ifdef BUILD_HDF5
-    else if (cgio->type == CGIO_FILE_HDF5) {
-        ADFH_Read_All_Data(id, m_data_type, (char *)data, &ierr);
+      /* m_data_type is ignored since changing type when reading is not 
+         supported with adf files.  In practice, we convert first and 
+         call cgio_read_all_data_type */
+        ADF_Read_All_Data(id, m_data_type, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#endif
-    else {
-        return set_error(CGIO_ERR_FILE_TYPE);
-    }
-
-    return CGIO_ERR_NONE;
-}
-
-/*---------------------------------------------------------*/
-
-int cgio_read_block_data (int cgio_num, double id,
-    cgsize_t b_start, cgsize_t b_end, void *data)
-{
-    int ierr;
-    cgns_io *cgio;
-
-    if ((cgio = get_cgnsio(cgio_num, 0)) == NULL)
-        return get_error();
-
-    if (cgio->type == CGIO_FILE_ADF || cgio->type == CGIO_FILE_ADF2) {
-        ADF_Read_Block_Data(id, b_start, b_end, (char *)data, &ierr);
-        if (ierr > 0) return set_error(ierr);
-    }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
-        ADFH_Read_Block_Data(id, b_start, b_end, (char *)data, &ierr);
+        ADFH_Read_All_Data(id, m_data_type, data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
 #endif
@@ -1780,11 +1731,8 @@ int cgio_read_block_data (int cgio_num, double id,
 
 /*---------------------------------------------------------*/
 
-int cgio_read_data (int cgio_num, double id,
-    const cgsize_t *s_start, const cgsize_t *s_end,
-    const cgsize_t *s_stride,int m_num_dims,
-    const cgsize_t *m_dims, const cgsize_t *m_start,
-    const cgsize_t *m_end, const cgsize_t *m_stride, void *data)
+int cgio_read_block_data_type (int cgio_num, double id,
+    cgsize_t b_start, cgsize_t b_end, const char *m_data_type, void *data)
 {
     int ierr;
     cgns_io *cgio;
@@ -1793,14 +1741,12 @@ int cgio_read_data (int cgio_num, double id,
         return get_error();
 
     if (cgio->type == CGIO_FILE_ADF || cgio->type == CGIO_FILE_ADF2) {
-        ADF_Read_Data(id, s_start, s_end, s_stride, m_num_dims,
-            m_dims, m_start, m_end, m_stride, (char *)data, &ierr);
+        ADF_Read_Block_Data(id, b_start, b_end, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
-        ADFH_Read_Data(id, s_start, s_end, s_stride, NULL, m_num_dims,
-            m_dims, m_start, m_end, m_stride, (char *)data, &ierr);
+        ADFH_Read_Block_Data(id, b_start, b_end, m_data_type, data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
 #endif
@@ -1826,14 +1772,14 @@ int cgio_read_data_type (int cgio_num, double id,
         return get_error();
 
     if (cgio->type == CGIO_FILE_ADF || cgio->type == CGIO_FILE_ADF2) {
-         /* Changing type when reading is not supported with adf files.  In
-            practice, we convert first and call cgio_read_data */
-        return set_error(CGIO_ERR_NOT_HDF5);
+        ADF_Read_Data(id, s_start, s_end, s_stride, m_num_dims,
+            m_dims, m_start, m_end, m_stride, m_data_type, (char *)data, &ierr);
+        if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
-        ADFH_Read_Data(id, s_start, s_end, s_stride, m_data_type, m_num_dims,
-            m_dims, m_start, m_end, m_stride, (char *)data, &ierr);
+        ADFH_Read_Data(id, s_start, s_end, s_stride, m_num_dims,
+            m_dims, m_start, m_end, m_stride, m_data_type, data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
 #endif
@@ -1861,7 +1807,7 @@ int cgio_set_name (int cgio_num, double pid, double id,
         ADF_Put_Name(pid, id, name, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Put_Name(pid, id, name, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1888,7 +1834,7 @@ int cgio_set_label (int cgio_num, double id, const char *label)
         ADF_Set_Label(id, label, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Set_Label(id, label, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1916,9 +1862,9 @@ int cgio_set_dimensions (int cgio_num, double id,
         ADF_Put_Dimension_Information(id, data_type, num_dims, dims, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
-        ADFH_Put_Dimension_Information(id, data_type, num_dims, dims, &ierr);
+      ADFH_Put_Dimension_Information(id, data_type, num_dims, dims, HDF5storage_type, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
 #endif
@@ -1944,7 +1890,7 @@ int cgio_write_all_data (int cgio_num, double id,
         ADF_Write_All_Data(id, (const char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Write_All_Data(id, NULL, (const char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1973,7 +1919,7 @@ int cgio_write_all_data_type (int cgio_num, double id, const char *m_data_type,
             practice, we convert first and call cgio_write_all_data */
         return set_error(CGIO_ERR_NOT_HDF5);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Write_All_Data(id, m_data_type, (const char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -2001,7 +1947,7 @@ int cgio_write_block_data (int cgio_num, double id,
         ADF_Write_Block_Data(id, b_start, b_end, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Write_Block_Data(id, b_start, b_end, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -2033,7 +1979,7 @@ int cgio_write_data (int cgio_num, double id,
             m_dims, m_start, m_end, m_stride, (const char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Write_Data(id, s_start, s_end, s_stride, NULL, m_num_dims,
             m_dims, m_start, m_end, m_stride, (const char *)data, &ierr);
@@ -2066,7 +2012,7 @@ int cgio_write_data_type (int cgio_num, double id,
             practice, we convert first and call cgio_write_data */
         return set_error(CGIO_ERR_NOT_HDF5);
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
         ADFH_Write_Data(id, s_start, s_end, s_stride, m_data_type, m_num_dims,
             m_dims, m_start, m_end, m_stride, (const char *)data, &ierr);
diff --git a/src/cgns_io.h b/src/cgns_io.h
index aa109912887..e62c0d185e1 100644
--- a/ThirdParty/cgns/vtkcgns/src/cgns_io.h
+++ b/ThirdParty/cgns/vtkcgns/src/cgns_io.h
@@ -49,6 +49,10 @@
 #define CGIO_FILE_HDF5   2
 #define CGIO_FILE_ADF2   3
 
+#define CGIO_CONTIGUOUS 0
+#define CGIO_COMPACT    1
+#define CGIO_CHUNKED    2
+
 /* currently these are the same as for ADF */
 
 #define CGIO_MAX_DATATYPE_LENGTH  2
@@ -357,12 +361,6 @@ CGEXTERN int cgio_get_dimensions (
     cgsize_t *dims
 );
 
-CGEXTERN int cgio_read_all_data (
-    int cgio_num,
-    double id,
-    void *data
-);
-
 CGEXTERN int cgio_read_all_data_type (
     int cgio_num,
     double id,
@@ -370,25 +368,12 @@ CGEXTERN int cgio_read_all_data_type (
     void *data
 );
 
-CGEXTERN int cgio_read_block_data (
+CGEXTERN int cgio_read_block_data_type (
     int cgio_num,
     double id,
     cgsize_t b_start,
     cgsize_t b_end,
-    void *data
-);
-
-CGEXTERN int cgio_read_data (
-    int cgio_num,
-    double id,
-    const cgsize_t *s_start,
-    const cgsize_t *s_end,
-    const cgsize_t *s_stride,
-    int m_num_dims,
-    const cgsize_t *m_dims,
-    const cgsize_t *m_start,
-    const cgsize_t *m_end,
-    const cgsize_t *m_stride,
+    const char *m_data_type,
     void *data
 );
 
diff --git a/src/cgnsconfig.h.in b/src/cgnsconfig.h.in
index 786b4195ade..5edad0385e4 100644
--- a/ThirdParty/cgns/vtkcgns/src/cgnsconfig.h.in
+++ b/ThirdParty/cgns/vtkcgns/src/cgnsconfig.h.in
@@ -35,10 +35,8 @@
 #ifndef CGNSCONFIG_H
 #define CGNSCONFIG_H
 
-#define CG_BUILD_HDF5      @BUILDHDF5@
 #define CG_BUILD_DEBUG     @BUILDDEBUG@
 #define CG_BUILD_FORTRAN   @BUILDFORTRAN@
-#define CG_BUILD_PARALLEL  @BUILDPARALLEL@
 #define CG_BUILD_BASESCOPE @BUILDBASESCOPE@
 
 #define HDF5_INCLUDE_PATH "@HDF5INC@"
diff --git a/src/cgnslib.c b/src/cgnslib.c
index 7b4110b0657..929eb2d9847 100644
--- a/ThirdParty/cgns/vtkcgns/src/cgnslib.c
+++ b/ThirdParty/cgns/vtkcgns/src/cgnslib.c
@@ -53,7 +53,7 @@ freely, subject to the following restrictions:
 #include "cgns_io.h"
 
 /* to determine default file type */
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
 # include "vtk_hdf5.h"
 #endif
 
@@ -98,6 +98,9 @@ int cgns_compress = 0;
 int cgns_filetype = CG_FILE_NONE;
 void* cgns_rindindex = CG_CONFIG_RIND_CORE;
 
+/* Flag for contiguous (0) or compact storage (1) */
+int HDF5storage_type = CG_COMPACT;
+
 extern void (*cgns_error_handler)(int, char *);
 
 /***********************************************************************
@@ -260,7 +263,7 @@ int VersionList[] = {3210, 3200,
                      2550, 2540, 2530, 2520, 2510, 2500,
                      2460, 2420, 2400,
                      2300, 2200, 2100, 2000, 1270, 1200, 1100, 1050};
-#define nVersions (sizeof(VersionList)/sizeof(int))
+#define nVersions ((int)(sizeof(VersionList)/sizeof(int)))
 
 #ifdef DEBUG_HDF5_OBJECTS_CLOSE
 void objlist_status(char *tag)
@@ -291,15 +294,15 @@ void objlist_status(char *tag)
     {
       if (H5Iis_valid(idlist[n]))
       {
-      	printf("{%s} track %d INVALID\n",tag,idlist[n]);
+        printf("{%s} track %d INVALID\n",tag,idlist[n]);
       }
       else
       {
-      	H5Oget_info(idlist[n],&objinfo);
-      	memset(oname,'\0',256);
-      	sname=H5Iget_name(idlist[n],oname,0);
-      	sname=H5Iget_name(idlist[n],oname,sname+1);
-      	printf("{%s} track %d ALIVE (%s:%d)\n",tag,idlist[n],oname,objinfo.rc);
+        H5Oget_info(idlist[n],&objinfo);
+        memset(oname,'\0',256);
+        sname=H5Iget_name(idlist[n],oname,0);
+        sname=H5Iget_name(idlist[n],oname,sname+1);
+        printf("{%s} track %d ALIVE (%s:%d)\n",tag,idlist[n],oname,objinfo.rc);
       }
     }
   }
@@ -341,7 +344,7 @@ int cg_open(const char *filename, int mode, int *file_number)
 
 #ifdef __CG_MALLOC_H__
     fprintf(stderr, "CGNS MEM_DEBUG: before open:files %d/%d: memory %d/%d: calls %d/%d\n", n_open,
-	    cgns_file_size, cgmemnow(), cgmemmax(), cgalloccalls(), cgfreecalls());
+           cgns_file_size, cgmemnow(), cgmemmax(), cgalloccalls(), cgfreecalls());
 #endif
 
     /* check file mode */
@@ -502,7 +505,7 @@ int cg_open(const char *filename, int mode, int *file_number)
 
 #ifdef __CG_MALLOC_H__
     fprintf(stderr, "CGNS MEM_DEBUG: after  open:files %d/%d: memory %d/%d: calls %d/%d\n", n_open,
-	    cgns_file_size, cgmemnow(), cgmemmax(), cgalloccalls(), cgfreecalls());
+           cgns_file_size, cgmemnow(), cgmemmax(), cgalloccalls(), cgfreecalls());
 #endif
 
     return CG_OK;
@@ -534,7 +537,7 @@ int cg_version(int file_number, float *FileVersion)
         return CG_ERROR;
     } else {
         int vers, ndim, temp_version;
-	cgsize_t dim_vals[12];
+        cgsize_t dim_vals[12];
         char_33 node_name;
         char_33 data_type;
         void *data;
@@ -620,7 +623,7 @@ int cg_close(int file_number)
 
 #ifdef __CG_MALLOC_H__
     fprintf(stderr, "CGNS MEM_DEBUG: before close:files %d/%d: memory %d/%d: calls %d/%d\n", n_open,
-	    cgns_file_size, cgmemnow(), cgmemmax(), cgalloccalls(), cgfreecalls());
+           cgns_file_size, cgmemnow(), cgmemmax(), cgalloccalls(), cgfreecalls());
 #endif
 
     if (cgns_compress && cg->mode == CG_MODE_MODIFY &&
@@ -655,7 +658,7 @@ int cg_close(int file_number)
 
 #ifdef __CG_MALLOC_H__
     fprintf(stderr, "CGNS MEM_DEBUG: after  close:files %d/%d: memory %d/%d: calls %d/%d\n", n_open,
-	    cgns_file_size, cgmemnow(), cgmemmax(), cgalloccalls(), cgfreecalls());
+           cgns_file_size, cgmemnow(), cgmemmax(), cgalloccalls(), cgfreecalls());
 #endif
 
 #ifdef DEBUG_HDF5_OBJECTS_CLOSE
@@ -697,19 +700,19 @@ int cg_set_file_type(int file_type)
 {
     if (file_type == CG_FILE_NONE) {
         char *type = getenv("CGNS_FILETYPE");
-	if (type == NULL || !*type) {
-#if defined(BUILD_HDF5)
+        if (type == NULL || !*type) {
+#if CG_BUILD_HDF5
             cgns_filetype = CG_FILE_HDF5;
 #else
             cgns_filetype = CG_FILE_ADF;
 #endif
         }
-#ifdef BUILD_HDF5
-	else if (*type == '2' || *type == 'h' || *type == 'H') {
+#if CG_BUILD_HDF5
+        else if (*type == '2' || *type == 'h' || *type == 'H') {
             cgns_filetype = CG_FILE_HDF5;
         }
 #endif
-	else if (*type == '3' || ((*type == 'a' || *type == 'A') &&
+    else if (*type == '3' || ((*type == 'a' || *type == 'A') &&
                  strchr(type, '2') != NULL)) {
 #if CG_SIZEOF_SIZE == 64
             cgi_error("ADF2 not supported in 64-bit mode");
@@ -717,7 +720,7 @@ int cg_set_file_type(int file_type)
 #else
             cgns_filetype = CG_FILE_ADF2;
 #endif
-	}
+        }
         else
             cgns_filetype = CG_FILE_ADF;
     }
@@ -1026,7 +1029,7 @@ int cg_cell_dim(int file_number, int B, int *cell_dim)
 }
 
 int cg_base_write(int file_number, const char * basename, int cell_dim,
-		  int phys_dim, int *B)
+                 int phys_dim, int *B)
 {
     cgns_base *base = NULL;
     int index;
@@ -1180,7 +1183,7 @@ int cg_index_dim(int file_number, int B, int Z, int *index_dim)
 }
 
 int cg_zone_write(int file_number, int B, const char *zonename, const cgsize_t * nijk,
-		  CGNS_ENUMT( ZoneType_t )  type, int *Z)
+          CGNS_ENUMT( ZoneType_t )  type, int *Z)
 {
     cgns_base *base;
     cgns_zone *zone = NULL;
@@ -1302,9 +1305,8 @@ int cg_nfamilies(int file_number, int B, int *nfamilies)
 }
 
 int cg_family_read(int file_number, int B, int F, char *family_name,
-	           int *nboco, int *ngeos)
+               int *nboco, int *ngeos)
 {
-
     cgns_family *family;
 
     cg = cgi_get_file(file_number);
@@ -1322,63 +1324,150 @@ int cg_family_read(int file_number, int B, int F, char *family_name,
     return CG_OK;
 }
 
+/* ** FAMILY TREE ** */
 int cg_family_write(int file_number, int B, const char * family_name, int *F)
 {
     int index;
-    cgns_base *base;
+    cgns_base   *base;
     cgns_family *family = NULL;
 
-     /* verify input */
-    if (cgi_check_strlen(family_name)) return CG_ERROR;
+    char family_name_path[(CGIO_MAX_NAME_LENGTH+1)*CG_MAX_GOTO_DEPTH+1];
+    char *pch, *tok;
+    int   skip = 0;
 
+    /* Check file access */
     cg = cgi_get_file(file_number);
     if (cg == 0) return CG_ERROR;
 
     if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_WRITE)) return CG_ERROR;
 
-     /* get memory address for base */
+    /* Check family name validity */
+    if ( strlen( family_name ) == 0 ){
+        cgi_error( "Family name is empty" );
+        return CG_ERROR;
+    }
+    if ( strlen( family_name ) > (CGIO_MAX_NAME_LENGTH+1)*CG_MAX_GOTO_DEPTH ){
+        cgi_error( "Family name is too long" );
+        return CG_ERROR;
+    }
+
+    /* get memory address for base */
     base = cgi_get_base(cg, B);
     if (base==0) return CG_ERROR;
 
-     /* Overwrite a Family_t Node: */
-    for (index=0; index<base->nfamilies; index++) {
-        if (strcmp(family_name, base->family[index].name)==0) {
 
-             /* in CG_MODE_WRITE, children names must be unique */
-            if (cg->mode==CG_MODE_WRITE) {
-                cgi_error("Duplicate child name found: %s",family_name);
-                return CG_ERROR;
-            }
+    /* check if family_name is actually a family tree path instead */
+    pch = strchr( family_name, '/' );
+    if( pch != 0 ) {
 
-             /* overwrite an existing zone */
-             /* delete the existing zone from file */
-            if (cgi_delete_node(base->id, base->family[index].id))
-                return CG_ERROR;
-             /* save the old in-memory address to overwrite */
-            family = &(base->family[index]);
-             /* free memory */
-            cgi_free_family(family);
-            break;
+        /* Check that family tree path is absolute */
+        if( pch != family_name ) {
+            cgi_error( "Family tree path must be absolute (including base)");
+            return CG_ERROR;
         }
-    }
-     /* ... or add a Family_t Node: */
-    if (index==base->nfamilies) {
-        if (base->nfamilies == 0) {
-            base->family = CGNS_NEW(cgns_family, base->nfamilies+1);
-        } else {
-            base->family = CGNS_RENEW(cgns_family, base->nfamilies+1, base->family);
+
+        /* Check that specified base's name matches begining of family tree path */
+        pch = strstr( family_name, base->name );
+        if( pch != family_name+1 ) {
+            cgi_error( "Incompatible basename (%s) and family tree (%s)", base->name, family_name );
+            return CG_ERROR;
         }
-        family = &(base->family[base->nfamilies]);
-        base->nfamilies++;
+
+        /* points to base level instead of root in family tree path*/
+        pch += strlen( base->name );
+    }
+    else {
+        pch = (char*) family_name;
     }
-    (*F) = index+1;
 
-    memset(family, 0, sizeof(cgns_family));
-    strcpy(family->name, family_name);
+    /* Make a copy of family tree path (need non const string for tokenization loop) */
+    strcpy( family_name_path, pch );
 
-     /* save data in file */
-    if (cgi_new_node(base->id, family->name, "Family_t", &family->id,
-        "MT", 0, 0, 0)) return CG_ERROR;
+    /* Init tokenization loop:
+     * We work with pointer to variables to simplify switch from cgns_base structure
+     * variables to cgns_family structure variables.
+     *  */
+    int* nfamilies_p = &(base->nfamilies);
+    cgns_family** family_p = &(base->family);
+    double parent_id = base->id;
+
+    /* Start loop over token */
+    pch = strtok( family_name_path, "/" );
+    while( pch ) {
+
+        tok = pch;
+        pch = strtok (NULL, "/"); /* when pch is null, we are at leaf (last token)*/
+
+        /* Check token size, should be max 32 */
+        if (cgi_check_strlen(tok)) {
+            cgi_error( "Invalid Family_t node %s", tok );
+            return CG_ERROR;
+        }
+        skip = 0; /* Flag to skip node creation */
+        /* Look for token in existing Family_t childs */
+        for( index=0; index < (*nfamilies_p); index++ ) {
+
+            /* If found existing Family_t named as token within the Family_t childs */
+            if( strcmp( tok, (*family_p)[index].name) == 0 ) {
+
+                /* If last token, then overwriting action */
+                if( !pch ) {
+
+                    /* Overwriting action not allowed on pure write mode */
+                    if( cg->mode == CG_MODE_WRITE ) {
+                        cgi_error( "Duplicate child name found: %s", tok );
+                        return CG_ERROR;
+                    }
+                    /* Modify mode : overwrite an existing family */
+                    if( cgi_delete_node( parent_id, (*family_p)[index].id )) {
+                        return CG_ERROR;
+                    }
+                    /* Save the old in-memory address to overwrite */
+                    family = &( (*family_p)[index] );
+                    /* free memory */
+                    cgi_free_family(family);
+                    break; /* quit "for" loop */
+
+                }
+                /* else, progressing in family tree path */
+                else {
+                    family = &( (*family_p)[index] ); /* ?? */
+                    skip = 1; /* intermediate node exists and should not be created or overwritten */
+                    break;
+                }
+
+            }
+        }
+
+        /* ... or add a Family_t Node */
+        if( index == *nfamilies_p ) {
+            if( *nfamilies_p == 0 ) {
+                *family_p = CGNS_NEW( cgns_family, (*nfamilies_p)+1 );
+            } else {
+                *family_p = CGNS_RENEW( cgns_family, (*nfamilies_p)+1, *family_p );
+            }
+            family = &( (*family_p)[*nfamilies_p] );
+            (*nfamilies_p)++;
+        }
+
+        (*F) = index+1;
+
+        if( ! skip ) { /* If not an existing intermediate family node */
+            memset( family, 0, sizeof(cgns_family) );
+            strcpy( family->name, tok );
+
+            /* Save data in file */
+            if( cgi_new_node( parent_id, tok, "Family_t", &family->id, "MT", 0, 0, 0) ) {
+                return CG_ERROR;
+            }
+        }
+
+        /* Update variables for next token */
+        nfamilies_p = &(family->nfamilies);
+        family_p    = &(family->family);
+        parent_id   = family->id;
+
+    } /* End of tokenization loop */
 
     return CG_OK;
 }
@@ -1421,7 +1510,7 @@ int cg_family_name_read(int file_number, int B, int F, int N, char *name, char *
     strcpy(family, fam->famname[N-1].family);
     return CG_OK;
 }
-
+/* ** FAMILY TREE ** */
 int cg_family_name_write(int file_number, int B, int F,
                          const char *name, const char *family)
 {
@@ -1431,8 +1520,12 @@ int cg_family_name_write(int file_number, int B, int F,
     cgns_famname *famname = 0;
 
      /* verify input */
-    if (cgi_check_strlen(name) ||
-        cgi_check_strlen(family)) return CG_ERROR;
+    if (cgi_check_strlen(name)) return CG_ERROR;
+
+    if ( strlen(family) > (CGIO_MAX_NAME_LENGTH+1)*CG_MAX_GOTO_DEPTH ) {
+        cgi_error( "Family path too long (%s, size %ld)", family, strlen(family) );
+        return CG_ERROR;
+    }
 
     cg = cgi_get_file(file_number);
     if (cg == 0) return CG_ERROR;
@@ -1474,10 +1567,239 @@ int cg_family_name_write(int file_number, int B, int F,
     return CG_OK;
 }
 
+/* ** FAMILY TREE ** */
+/* FamilyTree extension */
+int cg_node_family_write( const char* family_name, int* F)
+{
+    int ier=0, n, nfamilies;
+    cgns_family* family;
+    double posit_id;
+
+    CHECK_FILE_OPEN
+
+    /* verify input */
+    if( strchr( family_name, '/' ) != 0 ) {
+        cgi_error( "Path not allowed to create Family_t locally\n");
+        return CG_ERROR;
+    }
+    if( cgi_check_strlen( family_name ) ) return CG_ERROR;
+
+    /* check for valid posit */
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        (*F) = 0;
+        return CG_ERROR;
+    }
+
+    family = cgi_family_address( CG_MODE_WRITE, 0, family_name, &ier );
+    if( family==0 ) return ier;
+
+    memset( family, 0, sizeof( cgns_family ) );
+    strcpy( family->name, family_name );
+
+    /* save data in file */
+    if( cgi_posit_id( &posit_id ) ) return CG_ERROR;
+    if( cgi_new_node( posit_id, family_name, "Family_t", &family->id, "MT", 0, 0, 0))
+        return CG_ERROR;
+
+    /* retrieve index */
+    family = 0;
+    if( strcmp( posit->label, "CGNSBase_t" ) == 0 ) {
+        family = ((cgns_base*)posit->posit)->family;
+        nfamilies = ((cgns_base*)posit->posit)->nfamilies;
+    }
+    else if (strcmp(posit->label,"Family_t")==0) {
+        family = ((cgns_family *)posit->posit)->family;
+        nfamilies = ((cgns_family *)posit->posit)->nfamilies;
+    }
+    else {
+        cgi_error("Family_t node not supported under '%s' type node",posit->label);
+        (*F) = -1;
+        return CG_INCORRECT_PATH;
+    }
+
+
+    if( family ) {
+        for( n=0; n<nfamilies;n++ ){
+            if( strcmp( family_name, family[n].name) == 0 )
+                break;
+        }
+        if( n == nfamilies ) {
+            cgi_error( "Could not find Family_t node %s\n" , family_name );
+            return CG_ERROR;
+        }
+        *F = n + 1;
+    }
+    else {
+        cgi_error( "No Family_t container \n");
+        return CG_ERROR;
+    }
+
+    return CG_OK;
+}
+
+/* ** FAMILY TREE ** */
+int cg_node_nfamilies( int* nfamilies )
+{
+    /* This is valid and used during write as well as read mode. */
+
+    CHECK_FILE_OPEN
+
+    /* check for valid posit */
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        (*nfamilies) = 0;
+        return CG_ERROR;
+    }
+
+    if (strcmp(posit->label,"CGNSBase_t")==0 )
+        (*nfamilies) = ((cgns_base *)posit->posit)->nfamilies;
+    else if (strcmp(posit->label,"Family_t")==0)
+        (*nfamilies) = ((cgns_family *)posit->posit)->nfamilies;
+    else {
+        cgi_error("Family_t node not supported under '%s' type node",posit->label);
+        (*nfamilies) = 0;
+        return CG_INCORRECT_PATH;
+    }
+
+    return CG_OK;
+}
+
+/* ** FAMILY TREE ** */
+int cg_node_family_read( int F, char* family_name, int* nFamBC, int *nGeo )
+{
+    int ier = 0;
+    cgns_family* family;
+
+    CHECK_FILE_OPEN
+
+    /* verify input */
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_READ)) return CG_ERROR;
+
+    family = cgi_family_address( CG_MODE_READ, F, "dummy", &ier );
+    if( family == 0 ) return ier;
+
+    strcpy( family_name, family->name );
+    (*nFamBC) = family->nfambc;
+    (*nGeo)   = family->ngeos;
+
+    return CG_OK;
+}
+
+/* ** FAMILY TREE ** */
+int cg_node_family_name_write( const char* node_name, const char* family_name )
+{
+    int index;
+    cgns_family*  family  = 0;
+    cgns_famname* famname = 0;
+    cgsize_t dim;
+    CHECK_FILE_OPEN
+
+    /* verify input */
+    if( cgi_check_strlen( node_name ))   return CG_ERROR;
+
+    if ( strlen(family_name) > (CGIO_MAX_NAME_LENGTH+1)*CG_MAX_GOTO_DEPTH ) {
+        cgi_error( "Family path too long (%s, size %ld)", family_name, strlen(family_name) );
+        return CG_ERROR;
+    }
+
+    /* check for valid posit */
+
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        return CG_ERROR;
+    }
+
+    if (strcmp(posit->label,"Family_t")==0)
+        family = ((cgns_family *)posit->posit);
+
+    if( family==0 ) {
+        cgi_error( "cg_node_family_name_write not called at a Family_t position" );
+        return CG_ERROR;
+    }
+
+    for( index = 0; index < family->nfamname; index++ ) {
+        if( 0 == strcmp( node_name, family->famname[index].name )) {
+            if( cg->mode == CG_MODE_WRITE ) {
+                cgi_error("Duplicate child name found: %s", node_name );
+                return CG_ERROR;
+            }
+            if( cgi_delete_node( family->id, family->famname[index].id))
+                return CG_ERROR;
+            famname = &(family->famname[index]);
+            break;
+        }
+    }
+
+    if (index == family->nfamname) {
+        if (0 == family->nfamname)
+            family->famname = CGNS_NEW(cgns_famname, 1);
+        else
+            family->famname = CGNS_RENEW(cgns_famname, family->nfamname+1, family->famname);
+        famname = &family->famname[family->nfamname];
+        family->nfamname++;
+    }
+
+    strcpy(famname->name, node_name);
+    strcpy(famname->family, family_name);
+    dim = (cgsize_t)strlen(famname->family);
+
+    if (cgi_new_node(family->id, famname->name, "FamilyName_t", &famname->id,
+        "C1", 1, &dim, famname->family)) return CG_ERROR;
+
+    return CG_OK;
+}
+
+/* ** FAMILY TREE ** */
+int cg_node_nfamily_names( int* nnames )
+{
+    /* This is valid and used during write as well as read mode. */
+
+   CHECK_FILE_OPEN
+
+    /* check for valid posit */
+   if (posit == 0) {
+       cgi_error("No current position set by cg_goto\n");
+       (*nnames) = 0;
+       return CG_ERROR;
+   }
+
+   if (strcmp(posit->label,"Family_t")==0)
+       (*nnames) = ((cgns_family *)posit->posit)->nfamname;
+   else {
+       cgi_error("No array of FamilyName_t supported under '%s' type node",posit->label);
+       (*nnames) = 0;
+       return CG_INCORRECT_PATH;
+   }
+
+   return CG_OK;
+}
+
+/* ** FAMILY TREE ** */
+int cg_node_family_name_read(int N, char* node_name, char* family_name )
+{
+    cgns_famname *famname;
+    int ier = 0;
+
+    CHECK_FILE_OPEN
+
+    /* verify input */
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_READ)) return CG_ERROR;
+
+
+    famname = cgi_multfam_address(CG_MODE_READ, N, "", &ier);
+    if (famname==0) return ier;
+
+    strcpy(node_name, famname->name);
+    strcpy(family_name, famname->family);
+
+    return CG_OK;
+}
+
 /*----------------------------------------------------------------------*/
 
 int cg_fambc_read(int file_number, int B, int F, int BC,
-	          char *fambc_name, CGNS_ENUMT(BCType_t) *bocotype)
+              char *fambc_name, CGNS_ENUMT(BCType_t) *bocotype)
 {
     cgns_family *family;
 
@@ -1500,7 +1822,7 @@ int cg_fambc_read(int file_number, int B, int F, int BC,
 }
 
 int cg_fambc_write(int file_number, int B, int F, const char * fambc_name,
-		   CGNS_ENUMT( BCType_t )  bocotype, int *BC)
+           CGNS_ENUMT( BCType_t )  bocotype, int *BC)
 {
     int index;
     cgsize_t length;
@@ -1567,10 +1889,133 @@ int cg_fambc_write(int file_number, int B, int F, const char * fambc_name,
     return CG_OK;
 }
 
+/* FamilyTree extension */ /* ** FAMILY TREE ** */
+
+/*----------------------------------------------------------------------*/
+int cg_node_fambc_read( int BC, char* fambc_name,
+        CGNS_ENUMT(BCType_t) *bocotype)
+{
+    cgns_family*  family  = 0;
+
+    CHECK_FILE_OPEN
+
+    /* verify input */
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_READ)) return CG_ERROR;
+
+
+    /* check for valid posit */
+
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        return CG_ERROR;
+    }
+
+    if (strcmp(posit->label,"Family_t")==0)
+        family = ((cgns_family *)posit->posit);
+
+    if( family==0 ) {
+        cgi_error( "cg_node_fambc_read not called at a Family_t position" );
+        return CG_ERROR;
+    }
+
+    if (BC<=0 || BC>family->nfambc) {
+        cgi_error("Invalid family b.c. number");
+        return CG_ERROR;
+    }
+    strcpy(fambc_name,family->fambc[BC-1].name);
+    *bocotype = family->fambc[BC-1].type;
+
+    return CG_OK;
+}
+
+/*----------------------------------------------------------------------*/
+int cg_node_fambc_write( const char* fambc_name,
+        CGNS_ENUMT(BCType_t) bocotype, int *BC )
+{
+    int index;
+    cgsize_t length;
+    cgns_family *family = 0;
+    cgns_fambc *fambc = NULL;
+
+    /* verify input */
+/*  if (cgi_check_strlen(fambc_name)) return CG_ERROR; */
+    if (INVALID_ENUM(bocotype,NofValidBCTypes)) {
+        cgi_error("Invalid BCType:  %d",bocotype);
+        return CG_ERROR;
+    }
+
+     CHECK_FILE_OPEN
+
+    /* verify input */
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_WRITE)) return CG_ERROR;
+
+    /* check for valid posit */
+
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        return CG_ERROR;
+    }
+
+    if (strcmp(posit->label,"Family_t")==0)
+        family = ((cgns_family *)posit->posit);
+
+    if( family==0 ) {
+        cgi_error( "cg_node_fambc_write not called at a Family_t position" );
+        return CG_ERROR;
+    }
+
+
+    /* Overwrite a FamilyBC_t Node: */
+    for (index=0; index<family->nfambc; index++) {
+        if (strcmp(fambc_name, family->fambc[index].name)==0) {
+
+             /* in CG_MODE_WRITE, children names must be unique */
+            if (cg->mode==CG_MODE_WRITE) {
+                cgi_error("Duplicate child name found: %s",fambc_name);
+                return CG_ERROR;
+            }
+
+             /* overwrite an existing zone */
+             /* delete the existing fambc from file */
+            if (cgi_delete_node(family->id, family->fambc[index].id))
+                return CG_ERROR;
+             /* save the old in-memory address to overwrite */
+            fambc = &(family->fambc[index]);
+             /* free memory */
+            cgi_free_fambc(fambc);
+            break;
+        }
+    }
+    /* ... or add a FamilyBC_t Node: */
+    if (index==family->nfambc) {
+        if (family->nfambc == 0) {
+            family->fambc = CGNS_NEW(cgns_fambc, family->nfambc+1);
+        } else {
+            family->fambc = CGNS_RENEW(cgns_fambc, family->nfambc+1, family->fambc);
+        }
+        fambc = &(family->fambc[family->nfambc]);
+        family->nfambc++;
+    }
+
+    (*BC) = index+1;
+
+    memset(fambc, 0, sizeof(cgns_fambc));
+    strcpy(fambc->name, fambc_name);
+    fambc->type = bocotype;
+
+    /* save data in file */
+    length = (cgsize_t)strlen(BCTypeName[bocotype]);
+    if (cgi_new_node(family->id, fambc->name, "FamilyBC_t", &fambc->id,
+        "C1", 1, &length, BCTypeName[bocotype])) return CG_ERROR;
+
+    return CG_OK;
+}
+
+
 /*----------------------------------------------------------------------*/
 
 int cg_geo_read(int file_number, int B, int F, int G, char *geo_name,
-	        char **geo_file, char *CAD_name, int *npart)
+            char **geo_file, char *CAD_name, int *npart)
 {
     cgns_family *family;
 
@@ -1683,6 +2128,151 @@ int cg_geo_write(int file_number, int B, int F, const char * geo_name,
     return CG_OK;
 }
 
+/* FamilyTree extension */ /* ** FAMILY TREE ** */
+
+/*----------------------------------------------------------------------*/
+int cg_node_geo_read( int G, char *geo_name,
+        char **geo_file, char *CAD_name, int *npart )
+{
+    cgns_family*  family  = 0;
+
+    CHECK_FILE_OPEN
+
+    /* verify input */
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_READ)) return CG_ERROR;
+
+
+    /* check for valid posit */
+
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        return CG_ERROR;
+    }
+
+    if (strcmp(posit->label,"Family_t")==0)
+        family = ((cgns_family *)posit->posit);
+
+    if( family==0 ) {
+        cgi_error( "cg_node_geo_read not called at a Family_t position" );
+        return CG_ERROR;
+    }
+
+    if (G<=0 || G>family->ngeos) {
+        cgi_error("Invalid geometry reference number");
+        return CG_ERROR;
+    }
+    strcpy(geo_name,family->geo[G-1].name);
+    strcpy(CAD_name,family->geo[G-1].format);
+
+     /* This string is not limited to 32 characters and can't be pre-allocated
+    in the application */
+    geo_file[0]=CGNS_NEW(char,strlen(family->geo[G-1].file)+1);
+    strcpy(geo_file[0],family->geo[G-1].file);
+
+    *npart=family->geo[G-1].npart;
+
+    return CG_OK;
+}
+
+/*----------------------------------------------------------------------*/
+int cg_node_geo_write( const char *geo_name,
+        const char *filename, const char *CADname, int *G)
+{
+    int index;
+    cgsize_t length;
+    cgns_family *family = 0;
+    cgns_geo *geo = NULL;
+    double dummy_id;
+
+     /* verify input */
+    if (cgi_check_strlen(geo_name)) return CG_ERROR;
+    if (cgi_check_strlen(CADname)) return CG_ERROR;
+
+    CHECK_FILE_OPEN
+
+    /* verify input */
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_WRITE)) return CG_ERROR;
+
+    /* check for valid posit */
+
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        return CG_ERROR;
+    }
+
+    if (strcmp(posit->label,"Family_t")==0)
+        family = ((cgns_family *)posit->posit);
+
+    if( family==0 ) {
+        cgi_error( "cg_node_geo_write not called at a Family_t position" );
+        return CG_ERROR;
+    }
+
+     /* Overwrite a GeometryReference_t Node: */
+    for (index=0; index<family->ngeos; index++) {
+        if (strcmp(geo_name, family->geo[index].name)==0) {
+
+             /* in CG_MODE_WRITE, children names must be unique */
+            if (cg->mode==CG_MODE_WRITE) {
+                cgi_error("Duplicate child name found: %s",geo_name);
+                return CG_ERROR;
+            }
+
+             /* overwrite an existing zone */
+             /* delete the existing geo from file */
+            if (cgi_delete_node(family->id, family->geo[index].id))
+                return CG_ERROR;
+             /* save the old in-memory address to overwrite */
+            geo = &(family->geo[index]);
+             /* free memory */
+            cgi_free_geo(geo);
+            break;
+        }
+    }
+     /* ... or add a GeometryReference_t Node: */
+    if (index==family->ngeos) {
+        if (family->ngeos == 0) {
+            family->geo = CGNS_NEW(cgns_geo, family->ngeos+1);
+        } else {
+            family->geo = CGNS_RENEW(cgns_geo, family->ngeos+1, family->geo);
+        }
+        geo = &(family->geo[family->ngeos]);
+        family->ngeos++;
+    }
+    (*G) = index+1;
+
+
+    memset(geo, 0, sizeof(cgns_geo));
+    strcpy(geo->name, geo_name);
+    strcpy(geo->format, CADname);
+
+    length = (int)strlen(filename);
+    if (length<=0) {
+        cgi_error("filename undefined for GeometryReference node!");
+        return CG_ERROR;
+    }
+    geo->file = (char *)malloc((size_t)((length+1)*sizeof(char)));
+    if (geo->file == NULL) {
+        cgi_error("Error allocation geo->file");
+        return CG_ERROR;
+    }
+    strcpy(geo->file, filename);
+
+     /* save data in file */
+    if (cgi_new_node(family->id, geo->name, "GeometryReference_t", &geo->id,
+        "MT", 0, 0, 0)) return CG_ERROR;
+    length = (cgsize_t)strlen(geo->file);
+    if (cgi_new_node(geo->id, "GeometryFile", "GeometryFile_t", &dummy_id,
+        "C1", 1, &length, geo->file)) return CG_ERROR;
+    length = (cgsize_t)strlen(geo->format);
+    if (cgi_new_node(geo->id, "GeometryFormat", "GeometryFormat_t", &dummy_id,
+        "C1", 1, &length, geo->format)) return CG_ERROR;
+
+    return CG_OK;
+}
+
+
+
 /*----------------------------------------------------------------------*/
 
 int cg_part_read(int file_number, int B, int F, int G, int P, char *part_name)
@@ -1772,6 +2362,121 @@ int cg_part_write(int file_number, int B, int F, int G, const char * part_name,
     return CG_OK;
 }
 
+/* FamilyTree extension */ /* ** FAMILY TREE ** */
+
+/*----------------------------------------------------------------------*/
+int cg_node_part_read(int G, int P, char *part_name)
+{
+    cgns_family*  family  = 0;
+
+    CHECK_FILE_OPEN
+
+    /* verify input */
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_READ)) return CG_ERROR;
+
+
+    /* check for valid posit */
+
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        return CG_ERROR;
+    }
+
+    if (strcmp(posit->label,"Family_t")==0)
+        family = ((cgns_family *)posit->posit);
+
+    if( family==0 ) {
+        cgi_error( "cg_node_part_read not called at a Family_t position" );
+        return CG_ERROR;
+    }
+
+    if (P<=0 || P>family->geo[G-1].npart) {
+        cgi_error("Invalid part number");
+        return CG_ERROR;
+    }
+    strcpy(part_name,family->geo[G-1].part[P-1].name);
+    return CG_OK;
+}
+
+/*----------------------------------------------------------------------*/
+int cg_node_part_write(int G, const char * part_name, int *P)
+{
+    int index;
+    cgns_geo *geo;
+    cgns_part *part = NULL;
+    cgns_family *family = 0;
+
+     /* verify input */
+    if (cgi_check_strlen(part_name)) return CG_ERROR;
+
+    CHECK_FILE_OPEN
+
+    /* verify input */
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_WRITE)) return CG_ERROR;
+
+    /* check for valid posit */
+
+    if (posit == 0) {
+        cgi_error("No current position set by cg_goto\n");
+        return CG_ERROR;
+    }
+
+    if (strcmp(posit->label,"Family_t")==0)
+        family = ((cgns_family *)posit->posit);
+
+    if( family==0 ) {
+        cgi_error( "cg_node_part_write not called at a Family_t position" );
+        return CG_ERROR;
+    }
+
+    if (G > family->ngeos || G <=0) {
+        cgi_error("Invalid index for GeometryEntity_t node");
+        return CG_ERROR;
+    }
+    geo = &family->geo[G-1];
+
+     /* Overwrite a GeometryEntity_t Node: */
+    for (index=0; index<geo->npart; index++) {
+        if (strcmp(part_name, geo->part[index].name)==0) {
+
+             /* in CG_MODE_WRITE, children names must be unique */
+            if (cg->mode==CG_MODE_WRITE) {
+                cgi_error("Duplicate child name found: %s",part_name);
+                return CG_ERROR;
+            }
+
+             /* overwrite an existing zone */
+             /* delete the existing geo from file */
+            if (cgi_delete_node(geo->id, geo->part[index].id))
+                return CG_ERROR;
+             /* save the old in-memory address to overwrite */
+            part = &(geo->part[index]);
+             /* free memory */
+            cgi_free_part(part);
+            break;
+        }
+    }
+     /* ... or add a GeometryReference_t Node: */
+    if (index==geo->npart) {
+        if (geo->npart == 0) {
+            geo->part = CGNS_NEW(cgns_part, geo->npart+1);
+        } else {
+            geo->part = CGNS_RENEW(cgns_part, geo->npart+1, geo->part);
+        }
+        part = &(geo->part[geo->npart]);
+        geo->npart++;
+    }
+    (*P) = index+1;
+
+    memset(part, 0, sizeof(cgns_part));
+    strcpy(part->name, part_name);
+
+     /* save data in file */
+    if (cgi_new_node(geo->id, part->name, "GeometryEntity_t", &part->id,
+        "MT", 0, 0, 0)) return CG_ERROR;
+    return CG_OK;
+}
+
 /*****************************************************************************\
  *    Read and Write DiscreteData_t Nodes
 \*****************************************************************************/
@@ -1900,7 +2605,7 @@ int cg_discrete_size(int file_number, int B, int Z, int D,
 /*----------------------------------------------------------------------*/
 
 int cg_discrete_ptset_info(int fn, int B, int Z, int D,
-	CGNS_ENUMT(PointSetType_t) *ptset_type, cgsize_t *npnts)
+    CGNS_ENUMT(PointSetType_t) *ptset_type, cgsize_t *npnts)
 {
     cgns_discrete *discrete;
 
@@ -1946,9 +2651,9 @@ int cg_discrete_ptset_read(int fn, int B, int Z, int D, cgsize_t *pnts)
 }
 
 int cg_discrete_ptset_write(int fn, int B, int Z,
-	const char *discrete_name, CGNS_ENUMT(GridLocation_t) location,
-	CGNS_ENUMT(PointSetType_t) ptset_type, cgsize_t npnts,
-	const cgsize_t *pnts, int *D)
+    const char *discrete_name, CGNS_ENUMT(GridLocation_t) location,
+    CGNS_ENUMT(PointSetType_t) ptset_type, cgsize_t npnts,
+    const cgsize_t *pnts, int *D)
 {
     int i, index_dim = 0;
     cgsize_t cnt, dim_vals = 1;
@@ -2112,6 +2817,120 @@ int cg_grid_write(int file_number, int B, int Z, const char * zcoorname, int *G)
     return CG_OK;
 }
 
+/*****************************************************************************\
+ *    Read and Write GridCoordinates_t bounding box
+\*****************************************************************************/
+
+int cg_grid_bounding_box_read(int file_number, int B, int Z, int G, CGNS_ENUMT(DataType_t) type, void* boundingbox)
+{
+    cgns_zcoor *zcoor;
+    cgns_base *base;
+    char_33 name;
+    char_33 data_type;
+    int ndim;
+    void * vdata;
+    cgsize_t dim_vals[12];
+    cgsize_t num;
+
+    cg = cgi_get_file(file_number);
+    if (cg == 0) return CG_ERROR;
+
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_READ)) return CG_ERROR;
+
+     /* Get memory address for GridCoordinates_t node */
+    zcoor = cgi_get_zcoor(cg, B, Z, G);
+    if (zcoor==0) return CG_ERROR;
+
+    /* Read Bounding box from GridCoordinates node data */
+    if (cgi_read_node(zcoor->id, name, data_type, &ndim, dim_vals, &vdata, READ_DATA)){
+        cgi_error("Error reading node GridCoordinates_t");
+        return CG_ERROR;
+    }
+
+    /* check bounding box is not an empty array*/
+    if (strcmp(data_type,"MT")==0) {
+        cgi_warning("No bounding box read");
+        return CG_OK;
+    }
+
+    if (strcmp(data_type,"R4") &&
+        strcmp(data_type,"R8")) {
+        cgi_error("Datatype %s not supported for coordinates bounding box", data_type);
+        return CG_ERROR;
+    }
+
+    if (ndim != 2) {
+        cgi_error("Grid coordinates bounding box is %d dimensional. It should be 2.", ndim);
+        return CG_ERROR;
+    }
+
+    base = cgi_get_base(cg, B);
+    if (base==0) return CG_ERROR;
+    num = 2*base->phys_dim;
+
+    if (dim_vals[0]*dim_vals[1] != num){
+        cgi_error("Grid coordinates bounding box is not coherent with physical dimension.");
+        return CG_ERROR;
+    }
+
+     /* verify input */
+    if (type != CGNS_ENUMV(RealSingle) && type != CGNS_ENUMV(RealDouble)) {
+        cgi_error("Invalid data type for bounding box array: %d", type);
+        return CG_ERROR;
+    }
+
+    /* transfer small bounding box data to user with correct data type */
+    cgi_convert_data(num, cgi_datatype(data_type), vdata, type, boundingbox);
+    CGNS_FREE(vdata);
+
+    return CG_OK;
+}
+
+int cg_grid_bounding_box_write(int file_number, int B, int Z, int G, CGNS_ENUMT(DataType_t) type, void* boundingbox)
+{
+    cgns_base *base;
+    cgns_zcoor *zcoor;
+    cgsize_t dim_vals[2];
+
+    cg = cgi_get_file(file_number);
+    if (cg == 0) return CG_ERROR;
+
+    if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_WRITE)) return CG_ERROR;
+
+    /* Get memory address for GridCoordinates_t node */
+    zcoor = cgi_get_zcoor(cg, B, Z, G);
+    if (zcoor==0) return CG_ERROR;
+
+    if (zcoor->id == 0){
+        cgi_error("Impossible to write coordinates bounding box to unwritten node");
+        return CG_ERROR;
+    }
+    base = cgi_get_base(cg, B);
+    if (base==0) return CG_ERROR;
+    dim_vals[0] = base->phys_dim;
+    dim_vals[1] = 2;
+
+    /* Check input */
+    if (boundingbox == NULL) return CG_OK;
+
+    if (type != CGNS_ENUMV(RealSingle) && type != CGNS_ENUMV(RealDouble)) {
+        cgi_error("Invalid data type for bounding box array: %d", type);
+        return CG_ERROR;
+    }
+
+    /* Write Bounding box into existing GridCoordinates_t node */
+    if (cgio_set_dimensions(cg->cgio, zcoor->id, cgi_adf_datatype(type), 2, dim_vals)) {
+       cg_io_error("cgio_set_dimensions");
+       return CG_ERROR;
+    }
+    if (cgio_write_all_data(cg->cgio, zcoor->id, boundingbox)){
+       cg_io_error("cgio_write_all_data");
+       return CG_ERROR;
+    }
+
+    return CG_OK;
+}
+
 /*****************************************************************************\
  *    Read and Write GridCoordinates_t/DataArray_t Nodes
 \*****************************************************************************/
@@ -2133,7 +2952,7 @@ int cg_ncoords(int file_number, int B, int Z, int *ncoords)
 }
 
 int cg_coord_info(int file_number, int B, int Z, int C, CGNS_ENUMT(DataType_t)  *type,
-	          char *coordname)
+              char *coordname)
 {
     cgns_zcoor *zcoor;
 
@@ -2269,7 +3088,16 @@ int cg_coord_write(int file_number, int B, int Z, CGNS_ENUMT(DataType_t) type,
     cgns_zone *zone;
     cgns_zcoor *zcoor;
     int n, m_numdim;
+    int status;
+
+    HDF5storage_type = CG_CONTIGUOUS;
 
+     /* verify input */
+    if (cgi_check_strlen(coordname)) return CG_ERROR;
+    if (type!=CGNS_ENUMV( RealSingle ) && type!=CGNS_ENUMV( RealDouble )) {
+        cgi_error("Invalid datatype for coord. array:  %d", type);
+        return CG_ERROR;
+    }
      /* get memory addresses */
     cg = cgi_get_file(file_number);
     if (cg == 0) return CG_ERROR;
@@ -2294,7 +3122,7 @@ int cg_coord_write(int file_number, int B, int Z, CGNS_ENUMT(DataType_t) type,
             s_rmin[n] = 1;
         }
         else {
-             /* new behavior consitent with SIDS */
+             /* new behavior consistent with SIDS */
             s_rmin[n] = 1 - zcoor->rind_planes[2*n];
         }
         s_rmax[n] = s_rmin[n] + m_dimvals[n] - 1;
@@ -2302,10 +3130,13 @@ int cg_coord_write(int file_number, int B, int Z, CGNS_ENUMT(DataType_t) type,
         m_rmax[n] = m_dimvals[n];
     }
 
-    return cg_coord_general_write(file_number, B, Z, coordname,
+    status = cg_coord_general_write(file_number, B, Z, coordname,
                                   type, s_rmin, s_rmax,
                                   type, m_numdim, m_dimvals, m_rmin, m_rmax,
                                   coord_ptr, C);
+
+    HDF5storage_type = CG_COMPACT;
+    return status;
 }
 
 int cg_coord_partial_write(int file_number, int B, int Z,
@@ -2316,6 +3147,7 @@ int cg_coord_partial_write(int file_number, int B, int Z,
 {
     cgns_zone *zone;
     int n, m_numdim;
+    int status;
 
      /* get memory addresses */
     cg = cgi_get_file(file_number);
@@ -2339,10 +3171,11 @@ int cg_coord_partial_write(int file_number, int B, int Z,
         m_dimvals[n] = m_rmax[n];
     }
 
-    return cg_coord_general_write(file_number, B, Z, coordname,
+    status = cg_coord_general_write(file_number, B, Z, coordname,
                                   type, s_rmin, s_rmax,
                                   type, m_numdim, m_dimvals, m_rmin, m_rmax,
                                   coord_ptr, C);
+    return status;
 }
 
 int cg_coord_general_write(int fn, int B, int Z, const char *coordname,
@@ -2357,6 +3190,9 @@ int cg_coord_general_write(int fn, int B, int Z, const char *coordname,
     cgns_zone *zone;
     cgns_zcoor *zcoor;
     int n, s_numdim;
+    int status;
+
+    HDF5storage_type = CG_CONTIGUOUS;
 
      /* verify input */
     if (cgi_check_strlen(coordname)) return CG_ERROR;
@@ -2397,7 +3233,7 @@ int cg_coord_general_write(int fn, int B, int Z, const char *coordname,
                              &zcoor->id, "MT", 0, 0, 0)) return CG_ERROR;
         }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
         hid_t hid;
         to_HDF_ID(zcoor->id, hid);
@@ -2411,12 +3247,14 @@ int cg_coord_general_write(int fn, int B, int Z, const char *coordname,
         return CG_ERROR;
     }
 
-    return cgi_array_general_write(zcoor->id, &(zcoor->ncoords),
+    status = cgi_array_general_write(zcoor->id, &(zcoor->ncoords),
                                    &(zcoor->coord), coordname,
                                    cgns_rindindex, zcoor->rind_planes,
                                    s_type, s_numdim, s_dimvals, s_rmin, s_rmax,
                                    m_type, m_numdim, m_dimvals, m_rmin, m_rmax,
                                    coord_ptr, C);
+    HDF5storage_type = CG_COMPACT;
+    return status;
 }
 
 /*****************************************************************************\
@@ -2459,7 +3297,7 @@ static void free_element_data(cgns_section *section)
 static int read_element_data(cgns_section *section)
 {
     if (section->connect->data == NULL) {
-	cgsize_t cnt = section->connect->dim_vals[0];
+    cgsize_t cnt = section->connect->dim_vals[0];
 
         section->connect->data = malloc(cnt * sizeof(cgsize_t));
         if (section->connect->data == NULL) {
@@ -2486,7 +3324,7 @@ static void free_offset_data(cgns_section *section)
 static int read_offset_data(cgns_section *section)
 {
     if (section->connect_offset->data == NULL) {
-	cgsize_t cnt = section->connect_offset->dim_vals[0];
+    cgsize_t cnt = section->connect_offset->dim_vals[0];
 
         section->connect_offset->data = malloc(cnt * sizeof(cgsize_t));
         if (section->connect_offset->data == NULL) {
@@ -2837,8 +3675,8 @@ int cg_poly_section_write(int file_number, int B, int Z, const char * SectionNam
 }
 
 int cg_section_partial_write(int file_number, int B, int Z, const char * SectionName,
-			     CGNS_ENUMT(ElementType_t) type, cgsize_t start,
-			     cgsize_t end, int nbndry, int *S)
+                 CGNS_ENUMT(ElementType_t) type, cgsize_t start,
+                 cgsize_t end, int nbndry, int *S)
 {
     cgns_zone *zone;
     cgns_section *section = NULL;
@@ -3010,10 +3848,10 @@ int cg_ElementDataSize(int file_number, int B, int Z, int S,
 }
 
 int cg_ElementPartialSize(int file_number, int B, int Z, int S,
-	cgsize_t start, cgsize_t end, cgsize_t *ElementDataSize)
+    cgsize_t start, cgsize_t end, cgsize_t *ElementDataSize)
 {
     cgns_section *section;
-    cgsize_t size, offset, *data, *offset_data;
+    cgsize_t size, *offset_data;
 
     cg = cgi_get_file(file_number);
     if (cg == 0) return CG_ERROR;
@@ -3230,10 +4068,10 @@ int cg_elements_partial_read(int file_number, int B, int Z, int S,
         m_stride[0] = 1;
         m_dim[0]    = size;
 
-        if (cgio_read_data(cg->cgio, section->connect->id,
-                           s_start, s_end, s_stride, 1, m_dim,
+        if (cgio_read_data_type(cg->cgio, section->connect->id,
+                           s_start, s_end, s_stride, CG_SIZE_DATATYPE, 1, m_dim,
                            m_start, m_end, m_stride, elements)) {
-            cg_io_error("cgio_read_data");
+            cg_io_error("cgio_read_data_type");
             return CG_ERROR;
         }
     } else {
@@ -3270,10 +4108,10 @@ int cg_elements_partial_read(int file_number, int B, int Z, int S,
                 m_dim[0]   = m_end[0];
                 m_dim[1]   = 4;
 
-                if (cgio_read_data(cg->cgio, section->parelem->id,
-                                   s_start, s_end, s_stride, 2, m_dim,
+                if (cgio_read_data_type(cg->cgio, section->parelem->id,
+                                   s_start, s_end, s_stride, CG_SIZE_DATATYPE, 2, m_dim,
                                    m_start, m_end, m_stride, parent_data)) {
-                    cg_io_error("cgio_read_data");
+                    cg_io_error("cgio_read_data_type");
                     return CG_ERROR;
                 }
             }
@@ -3281,7 +4119,7 @@ int cg_elements_partial_read(int file_number, int B, int Z, int S,
                 nn = section->parelem->dim_vals[0] * 4;
                 data = (cgsize_t *)malloc((size_t)(nn * sizeof(cgsize_t)));
                 if (data == NULL) {
-                    cgi_error("malloc failed for tempory ParentData array");
+                    cgi_error("malloc failed for temporary ParentData array");
                     return CG_ERROR;
                 }
                 if (cgi_read_int_data(section->parelem->id,
@@ -3315,20 +4153,20 @@ int cg_elements_partial_read(int file_number, int B, int Z, int S,
             m_dim[0]   = m_end[0];
             m_dim[1]   = 4;
 
-            if (cgio_read_data(cg->cgio, section->parelem->id,
-                               s_start, s_end, s_stride, 2, m_dim,
+            if (cgio_read_data_type(cg->cgio, section->parelem->id,
+                               s_start, s_end, s_stride, CG_SIZE_DATATYPE, 2, m_dim,
                                m_start, m_end, m_stride, parent_data)) {
-                cg_io_error("cgio_read_data");
+                cg_io_error("cgio_read_data_type");
                 return CG_ERROR;
             }
 
             m_start[1] = 3;
             m_end[1]   = 4;
 
-            if (cgio_read_data(cg->cgio, section->parface->id,
-                               s_start, s_end, s_stride, 2, m_dim,
+            if (cgio_read_data_type(cg->cgio, section->parface->id,
+                               s_start, s_end, s_stride, CG_SIZE_DATATYPE, 2, m_dim,
                                m_start, m_end, m_stride, parent_data)) {
-                cg_io_error("cgio_read_data");
+                cg_io_error("cgio_read_data_type");
                 return CG_ERROR;
             }
         }
@@ -3399,10 +4237,10 @@ int cg_poly_elements_partial_read(int file_number, int B, int Z, int S,
             m_stride[0] = 1;
             m_dim[0]    = size;
 
-            if (cgio_read_data(cg->cgio, section->connect->id,
-                               s_start, s_end, s_stride, 1, m_dim,
+            if (cgio_read_data_type(cg->cgio, section->connect->id,
+                               s_start, s_end, s_stride, CG_SIZE_DATATYPE, 1, m_dim,
                                m_start, m_end, m_stride, elements)) {
-                cg_io_error("cgio_read_data");
+                cg_io_error("cgio_read_data_type");
                 return CG_ERROR;
             }
         } else {
@@ -3434,10 +4272,10 @@ int cg_poly_elements_partial_read(int file_number, int B, int Z, int S,
             m_stride[0] = 1;
             m_dim[0]    = size;
 
-            if (cgio_read_data(cg->cgio, section->connect->id,
-                               s_start, s_end, s_stride, 1, m_dim,
+            if (cgio_read_data_type(cg->cgio, section->connect->id,
+                               s_start, s_end, s_stride, CG_SIZE_DATATYPE, 1, m_dim,
                                m_start, m_end, m_stride, elements)) {
-                cg_io_error("cgio_read_data");
+                cg_io_error("cgio_read_data_type");
                 return CG_ERROR;
             }
         } else {
@@ -3483,10 +4321,10 @@ int cg_poly_elements_partial_read(int file_number, int B, int Z, int S,
                 m_dim[0]   = m_end[0];
                 m_dim[1]   = 4;
 
-                if (cgio_read_data(cg->cgio, section->parelem->id,
-                                   s_start, s_end, s_stride, 2, m_dim,
+                if (cgio_read_data_type(cg->cgio, section->parelem->id,
+                                   s_start, s_end, s_stride, CG_SIZE_DATATYPE, 2, m_dim,
                                    m_start, m_end, m_stride, parent_data)) {
-                    cg_io_error("cgio_read_data");
+                    cg_io_error("cgio_read_data_type");
                     return CG_ERROR;
                 }
             }
@@ -3494,7 +4332,7 @@ int cg_poly_elements_partial_read(int file_number, int B, int Z, int S,
                 nn = section->parelem->dim_vals[0] * 4;
                 data = (cgsize_t *)malloc((size_t)(nn * sizeof(cgsize_t)));
                 if (data == NULL) {
-                    cgi_error("malloc failed for tempory ParentData array");
+                    cgi_error("malloc failed for temporary ParentData array");
                     return CG_ERROR;
                 }
                 if (cgi_read_int_data(section->parelem->id,
@@ -3528,20 +4366,20 @@ int cg_poly_elements_partial_read(int file_number, int B, int Z, int S,
             m_dim[0]   = m_end[0];
             m_dim[1]   = 4;
 
-            if (cgio_read_data(cg->cgio, section->parelem->id,
-                               s_start, s_end, s_stride, 2, m_dim,
+            if (cgio_read_data_type(cg->cgio, section->parelem->id,
+                               s_start, s_end, s_stride, CG_SIZE_DATATYPE, 2, m_dim,
                                m_start, m_end, m_stride, parent_data)) {
-                cg_io_error("cgio_read_data");
+                cg_io_error("cgio_read_data_type");
                 return CG_ERROR;
             }
 
             m_start[1] = 3;
             m_end[1]   = 4;
 
-            if (cgio_read_data(cg->cgio, section->parface->id,
-                               s_start, s_end, s_stride, 2, m_dim,
+            if (cgio_read_data_type(cg->cgio, section->parface->id,
+                               s_start, s_end, s_stride, CG_SIZE_DATATYPE, 2, m_dim,
                                m_start, m_end, m_stride, parent_data)) {
-                cg_io_error("cgio_read_data");
+                cg_io_error("cgio_read_data_type");
                 return CG_ERROR;
             }
         }
@@ -3798,7 +4636,7 @@ int cg_elements_partial_write(int file_number, int B, int Z, int S,
 
         newelems = (cgsize_t *)malloc((size_t)(cnt * newsize * sizeof(cgsize_t)));
         if (NULL == newelems) {
-            cgi_error("Error alocating new ParentElements data");
+            cgi_error("Error allocating new ParentElements data");
             return CG_ERROR;
         }
         offset = start - section->range[0];
@@ -3869,8 +4707,8 @@ int cg_elements_partial_write(int file_number, int B, int Z, int S,
 }
 
 int cg_poly_elements_partial_write(int file_number, int B, int Z, int S,
-			      cgsize_t start, cgsize_t end,
-			      const cgsize_t *elements, const cgsize_t *connect_offset)
+                  cgsize_t start, cgsize_t end,
+                  const cgsize_t *elements, const cgsize_t *connect_offset)
 {
     cgns_section *section;
     CGNS_ENUMT(ElementType_t) type;
@@ -4040,13 +4878,14 @@ int cg_poly_elements_partial_write(int file_number, int B, int Z, int S,
         /* create new element connectivity array and offsets*/
 
         newelems = (cgsize_t *) malloc ((size_t)(newsize * sizeof(cgsize_t)));
-        newoffsets = (cgsize_t *) malloc((size_t)((elemcount+1) * sizeof(cgsize_t)));
         if (NULL == newelems) {
             cgi_error("Error allocating new connectivity data");
             return CG_ERROR;
         }
+        newoffsets = (cgsize_t *) malloc((size_t)((elemcount+1) * sizeof(cgsize_t)));
         if (NULL == newoffsets) {
             cgi_error("Error allocating new connectivity offset data");
+            free(newelems);
             return CG_ERROR;
         }
 
@@ -4078,7 +4917,11 @@ int cg_poly_elements_partial_write(int file_number, int B, int Z, int S,
             } else if (end < section->range[1]) {
                 num = end - section->range[0] + 1;
                 offset = section_offset[end - section->range[0] + 1];
-                if (offset < 0) return CG_ERROR;
+                if (offset < 0) {
+                    free(newelems);
+                    free(newoffsets);
+                    return CG_ERROR;
+                }
                 size = section_offset[section->range[1]-section->range[0]+1] - section_offset[num];
                 memcpy(&newelems[n], &oldelems[offset], (size_t)(size*sizeof(cgsize_t)));
                 n += size;
@@ -4088,7 +4931,6 @@ int cg_poly_elements_partial_write(int file_number, int B, int Z, int S,
                 }
             }
         } else if (start > section->range[1]) {
-            cgsize_t ii;
             memcpy(newelems, oldelems, (size_t)(oldsize*sizeof(cgsize_t)));
             memcpy(newoffsets, section_offset, (size_t)((section->range[1]-section->range[0]+2)*sizeof(cgsize_t)));
             n += oldsize;
@@ -4110,7 +4952,6 @@ int cg_poly_elements_partial_write(int file_number, int B, int Z, int S,
                 j++;
             }
         } else {
-            cgsize_t ii;
             num = start - section->range[0];
             size = section_offset[num];
             memcpy(newelems, oldelems, (size_t)(size*sizeof(cgsize_t)));
@@ -4212,7 +5053,7 @@ int cg_poly_elements_partial_write(int file_number, int B, int Z, int S,
 
         newelems = (cgsize_t *)malloc((size_t)(cnt * newsize * sizeof(cgsize_t)));
         if (NULL == newelems) {
-            cgi_error("Error alocating new ParentElements data");
+            cgi_error("Error allocating new ParentElements data");
             return CG_ERROR;
         }
         offset = start - section->range[0];
@@ -4285,7 +5126,7 @@ int cg_poly_elements_partial_write(int file_number, int B, int Z, int S,
 /*----------------------------------------------------------------------*/
 
 int cg_parent_data_write(int file_number, int B, int Z, int S,
-			 const cgsize_t * parent_data)
+             const cgsize_t * parent_data)
 {
     cgns_section *section;
     cgsize_t num;
@@ -4422,7 +5263,7 @@ int cg_parent_data_partial_write(int file_number, int B, int Z, int S,
         return CG_ERROR;
     }
     if (size != section->parelem->dim_vals[0]) {
-        cgi_error("internal errror - invalid ParentElements data size !!!");
+        cgi_error("internal error - invalid ParentElements data size !!!");
         return CG_ERROR;
     }
 
@@ -4444,7 +5285,7 @@ int cg_parent_data_partial_write(int file_number, int B, int Z, int S,
             return CG_ERROR;
         }
         if (size != section->parface->dim_vals[0]) {
-            cgi_error("internal errror - invalid ParentElementsPosition data size !!!");
+            cgi_error("internal error - invalid ParentElementsPosition data size !!!");
             return CG_ERROR;
         }
     }
@@ -4493,7 +5334,7 @@ int cg_parent_data_partial_write(int file_number, int B, int Z, int S,
 
         if (read_parent_data(section)) return CG_ERROR;
 
-	data = (cgsize_t *)section->parelem->data;
+    data = (cgsize_t *)section->parelem->data;
         for (i = 0, num = 0; num < cnt; num++) {
             j = num * size + offset;
             for (n = start; n <= end; n++)
@@ -4541,7 +5382,7 @@ int cg_nsols(int file_number, int B, int Z, int *nsols)
 }
 
 int cg_sol_info(int file_number, int B, int Z, int S, char *solname,
-	        CGNS_ENUMT(GridLocation_t) *location)
+            CGNS_ENUMT(GridLocation_t) *location)
 {
     cgns_sol *sol;
 
@@ -4575,7 +5416,7 @@ int cg_sol_id(int file_number, int B, int Z, int S, double *sol_id)
 }
 
 int cg_sol_write(int file_number, int B, int Z, const char * solname,
-		 CGNS_ENUMT(GridLocation_t) location, int *S)
+         CGNS_ENUMT(GridLocation_t) location, int *S)
 {
     cgns_zone *zone;
     cgns_sol *sol = NULL;
@@ -4701,7 +5542,7 @@ int cg_sol_size(int file_number, int B, int Z, int S,
 /*----------------------------------------------------------------------*/
 
 int cg_sol_ptset_info(int fn, int B, int Z, int S,
-	CGNS_ENUMT(PointSetType_t) *ptset_type, cgsize_t *npnts)
+    CGNS_ENUMT(PointSetType_t) *ptset_type, cgsize_t *npnts)
 {
     cgns_sol *sol;
 
@@ -4747,9 +5588,9 @@ int cg_sol_ptset_read(int fn, int B, int Z, int S, cgsize_t *pnts)
 }
 
 int cg_sol_ptset_write(int fn, int B, int Z, const char *solname,
-	CGNS_ENUMT(GridLocation_t) location,
-	CGNS_ENUMT(PointSetType_t) ptset_type, cgsize_t npnts,
-	const cgsize_t *pnts, int *S)
+    CGNS_ENUMT(GridLocation_t) location,
+    CGNS_ENUMT(PointSetType_t) ptset_type, cgsize_t npnts,
+    const cgsize_t *pnts, int *S)
 {
     int i, index_dim = 0;
     cgsize_t cnt, dim_vals = 1;
@@ -4865,8 +5706,8 @@ int cg_field_read(int file_number, int B, int Z, int S, const char *fieldname,
 
      /* verify that range requested does not exceed range stored */
     if (s_rmin == NULL || s_rmax == NULL) {
-	cgi_error("NULL range value.");
-	return CG_ERROR;
+        cgi_error("NULL range value.");
+        return CG_ERROR;
     }
 
     cgsize_t m_dimvals[CGIO_MAX_DIMENSIONS];
@@ -4960,6 +5801,16 @@ int cg_field_write(int file_number, int B, int Z, int S,
     cgns_sol *sol;
     int n, m_numdim;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
+     /* verify input */
+    if (cgi_check_strlen(fieldname)) return CG_ERROR;
+    if (type != CGNS_ENUMV(RealSingle) && type != CGNS_ENUMV(RealDouble) &&
+        type != CGNS_ENUMV(Integer) && type != CGNS_ENUMV(LongInteger)) {
+        cgi_error("Invalid datatype for solution array %s: %d",fieldname, type);
+        return CG_ERROR;
+    }
+
      /* get memory addresses */
     cg = cgi_get_file(file_number);
     if (cg == 0) return CG_ERROR;
@@ -4991,7 +5842,7 @@ int cg_field_write(int file_number, int B, int Z, int S,
             s_rmin[n] = 1;
         }
         else {
-             /* new behavior consitent with SIDS */
+             /* new behavior consistent with SIDS */
             s_rmin[n] = 1 - sol->rind_planes[2*n];
         }
         s_rmax[n] = s_rmin[n] + m_dimvals[n] - 1;
@@ -5013,6 +5864,7 @@ int cg_field_partial_write(int file_number, int B, int Z, int S,
     cgns_zone *zone;
     cgns_sol *sol;
     int n, m_numdim;
+    int status;
 
      /* get memory addresses */
     cg = cgi_get_file(file_number);
@@ -5034,8 +5886,8 @@ int cg_field_partial_write(int file_number, int B, int Z, int S,
     }
 
     if (s_rmin == NULL || s_rmax == NULL) {
-	cgi_error("NULL range value.");
-	return CG_ERROR;
+        cgi_error("NULL range value.");
+        return CG_ERROR;
     }
 
     cgsize_t m_dimvals[CGIO_MAX_DIMENSIONS];
@@ -5046,10 +5898,14 @@ int cg_field_partial_write(int file_number, int B, int Z, int S,
         m_dimvals[n] = m_rmax[n];
     }
 
-    return cg_field_general_write(file_number, B, Z, S, fieldname,
+    status = cg_field_general_write(file_number, B, Z, S, fieldname,
                                   type, s_rmin, s_rmax,
                                   type, m_numdim, m_dimvals, m_rmin, m_rmax,
                                   field_ptr, F);
+
+    HDF5storage_type = CG_COMPACT;
+    return status;
+
 }
 
 int cg_field_general_write(int fn, int B, int Z, int S, const char *fieldname,
@@ -5064,6 +5920,9 @@ int cg_field_general_write(int fn, int B, int Z, int S, const char *fieldname,
     cgns_zone *zone;
     cgns_sol *sol;
     int s_numdim;
+    int status;
+
+    HDF5storage_type = CG_CONTIGUOUS;
 
      /* verify input */
     if (cgi_check_strlen(fieldname)) return CG_ERROR;
@@ -5104,12 +5963,15 @@ int cg_field_general_write(int fn, int B, int Z, int S, const char *fieldname,
         s_dimvals[0] = sol->ptset->size_of_patch;
     }
 
-    return cgi_array_general_write(sol->id, &(sol->nfields),
+    status= cgi_array_general_write(sol->id, &(sol->nfields),
                                    &(sol->field), fieldname,
                                    cgns_rindindex, sol->rind_planes,
                                    s_type, s_numdim, s_dimvals, s_rmin, s_rmax,
                                    m_type, m_numdim, m_dimvals, m_rmin, m_rmax,
                                    field_ptr, F);
+    
+    HDF5storage_type = CG_COMPACT;
+    return status;
 }
 
 /*************************************************************************\
@@ -5418,7 +6280,7 @@ int cg_subreg_gcname_write(int fn, int B, int Z, const char *name, int dimension
 }
 
 /*************************************************************************\
- *      Read and write ZoneGridConnectivity_t Nodes  			 *
+ *      Read and write ZoneGridConnectivity_t Nodes               *
 \*************************************************************************/
 
 int cg_nzconns(int fn, int B, int Z, int *nzconns)
@@ -5577,7 +6439,7 @@ int cg_nholes(int file_number, int B, int Z, int *nholes)
 }
 
 int cg_hole_info(int file_number, int B, int Z, int I, char *holename,
-		 CGNS_ENUMT(GridLocation_t) *location,
+         CGNS_ENUMT(GridLocation_t) *location,
                  CGNS_ENUMT(PointSetType_t) *ptset_type, int *nptsets,
                  cgsize_t *npnts)
 {
@@ -5664,9 +6526,9 @@ int cg_hole_id(int file_number, int B, int Z, int I, double *hole_id)
 }
 
 int cg_hole_write(int file_number, int B, int Z, const char * holename,
-		  CGNS_ENUMT(GridLocation_t) location,
-		  CGNS_ENUMT(PointSetType_t) ptset_type,
-		  int nptsets, cgsize_t npnts, const cgsize_t * pnts, int *I)
+          CGNS_ENUMT(GridLocation_t) location,
+          CGNS_ENUMT(PointSetType_t) ptset_type,
+          int nptsets, cgsize_t npnts, const cgsize_t * pnts, int *I)
 {
     cgns_zone *zone;
     cgns_zconn *zconn;
@@ -5778,16 +6640,16 @@ int cg_hole_write(int file_number, int B, int Z, const char * holename,
     if (cg->filetype == CGIO_FILE_ADF || cg->filetype == CGIO_FILE_ADF2) {
       if (zconn->id==0) {
         if (cgi_new_node(zone->id, zconn->name, "ZoneGridConnectivity_t",
-			 &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(zconn->id, hid);
       if (hid==0) {
         if (cgi_new_node(zone->id, zconn->name, "ZoneGridConnectivity_t",
-			 &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
 #endif
@@ -5810,7 +6672,7 @@ int cg_hole_write(int file_number, int B, int Z, const char * holename,
 
         if (ptset->npts > 0) {
              /* Create Point Set node on disk */
-	  if (ptset->type == CGNS_ENUMV(PointRange))
+      if (ptset->type == CGNS_ENUMV(PointRange))
                 sprintf(PointSetName, "PointRange%d",set+1);
             else
                 sprintf(PointSetName, "%s", PointSetTypeName[ptset->type]);
@@ -5842,12 +6704,12 @@ int cg_nconns(int file_number, int B, int Z, int *nconns)
 }
 
 /* in cg_conn_info, donor_datatype is useless starting with version 1.27, because
-   it's always I4.  Howver this arg. is left for backward compatibility of API
+   it's always I4.  However this arg. is left for backward compatibility of API
    and to be able to read old files */
 int cg_conn_info(int file_number, int B, int Z, int I, char *connectname,
-		 CGNS_ENUMT(GridLocation_t) *location,
+         CGNS_ENUMT(GridLocation_t) *location,
                  CGNS_ENUMT(GridConnectivityType_t) *type,
-		 CGNS_ENUMT(PointSetType_t) *ptset_type, cgsize_t *npnts,
+         CGNS_ENUMT(PointSetType_t) *ptset_type, cgsize_t *npnts,
                  char *donorname, CGNS_ENUMT(ZoneType_t) *donor_zonetype,
                  CGNS_ENUMT(PointSetType_t) *donor_ptset_type,
                  CGNS_ENUMT(DataType_t) *donor_datatype, cgsize_t *ndata_donor)
@@ -5936,10 +6798,10 @@ int cg_conn_read(int file_number, int B, int Z, int I, cgsize_t *pnts,
      /* read donor points from ADF file - data_type may be I4, R4 or R8 */
     if (conn->dptset.npts > 0) {
         cgns_ptset dptset = conn->dptset;
-        int index_dim = 0;
+        index_dim = 0;
         for (n=0; n<cg->base[B-1].nzones; n++) {
             if (strcmp(cg->base[B-1].zone[n].name,conn->donor)==0) {
-	        index_dim = cg->base[B-1].zone[n].type == CGNS_ENUMV(Structured) ? cell_dim : 1;
+            index_dim = cg->base[B-1].zone[n].type == CGNS_ENUMV(Structured) ? cell_dim : 1;
                 break;
             }
         }
@@ -5980,14 +6842,14 @@ int cg_conn_id(int file_number, int B, int Z, int I, double *conn_id)
 }
 
 int cg_conn_write(int file_number, int B, int Z,  const char * connectname,
-		  CGNS_ENUMT(GridLocation_t) location,
-		  CGNS_ENUMT(GridConnectivityType_t) type,
-		  CGNS_ENUMT(PointSetType_t) ptset_type,
-		  cgsize_t npnts, const cgsize_t * pnts, const char * donorname,
-		  CGNS_ENUMT(ZoneType_t) donor_zonetype,
-		  CGNS_ENUMT(PointSetType_t) donor_ptset_type,
+          CGNS_ENUMT(GridLocation_t) location,
+          CGNS_ENUMT(GridConnectivityType_t) type,
+          CGNS_ENUMT(PointSetType_t) ptset_type,
+          cgsize_t npnts, const cgsize_t * pnts, const char * donorname,
+          CGNS_ENUMT(ZoneType_t) donor_zonetype,
+          CGNS_ENUMT(PointSetType_t) donor_ptset_type,
                   CGNS_ENUMT(DataType_t) donor_datatype,
-		  cgsize_t ndata_donor, const cgsize_t * donor_data, int *I)
+          cgsize_t ndata_donor, const cgsize_t * donor_data, int *I)
 {
     cgns_zone *zone;
     cgns_zconn *zconn;
@@ -6202,16 +7064,16 @@ int cg_conn_write(int file_number, int B, int Z,  const char * connectname,
       /* Create node ZoneGridConnectivity_t node, if not yet created */
       if (zconn->id==0) {
         if (cgi_new_node(zone->id, zconn->name, "ZoneGridConnectivity_t",
-			 &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(zconn->id, hid);
       if (hid==0) {
         if (cgi_new_node(zone->id, zconn->name, "ZoneGridConnectivity_t",
-			 &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
 #endif
@@ -6245,7 +7107,7 @@ int cg_conn_write(int file_number, int B, int Z,  const char * connectname,
 
         /* Write pointset of donor */
         if (ndata_donor) {
-	    if (donor_zonetype==CGNS_ENUMV(Structured))
+        if (donor_zonetype==CGNS_ENUMV(Structured))
                 index_dim_donor = cell_dim;
             else
                 index_dim_donor=1;
@@ -6265,8 +7127,8 @@ int cg_conn_write_short(int file_number, int B, int Z,  const char * connectname
                         const char * donorname, int *I)
 {
     return cg_conn_write (file_number, B, Z,  connectname, location,
-			  type, ptset_type, npnts, pnts, donorname,
-			  CGNS_ENUMV(ZoneTypeNull), CGNS_ENUMV(PointSetTypeNull),
+              type, ptset_type, npnts, pnts, donorname,
+              CGNS_ENUMV(ZoneTypeNull), CGNS_ENUMV(PointSetTypeNull),
                           CGNS_ENUMV(DataTypeNull), 0, NULL, I);
 }
 
@@ -6470,8 +7332,8 @@ int cg_1to1_id(int file_number, int B, int Z, int I, double *one21_id)
 }
 
 int cg_1to1_write(int file_number, int B, int Z, const char * connectname,
-		  const char * donorname, const cgsize_t * range,
-		  const cgsize_t * donor_range, const int * transform, int *I)
+          const char * donorname, const cgsize_t * range,
+          const cgsize_t * donor_range, const int * transform, int *I)
 {
     cgns_zone *zone;
     cgns_zconn *zconn;
@@ -6519,11 +7381,11 @@ int cg_1to1_write(int file_number, int B, int Z, const char * connectname,
             return CG_ERROR;
         }
         if (abs(transform[i])>0) {
-	    cgsize_t dr, ddr;
+        cgsize_t dr, ddr;
             j = abs(transform[i])-1;
-	    dr = range[i+index_dim] - range[i];
-	    ddr = donor_range[j+index_dim] - donor_range[j];
-	    if (dr != ddr && dr != -ddr) {
+        dr = range[i+index_dim] - range[i];
+        ddr = donor_range[j+index_dim] - donor_range[j];
+        if (dr != ddr && dr != -ddr) {
                 cgi_error("Invalid input:  range = %d->%d and donor_range = %d->%d",
                 range[i], range[i+index_dim], donor_range[j], donor_range[j+index_dim]);
                 return CG_ERROR;
@@ -6591,16 +7453,16 @@ int cg_1to1_write(int file_number, int B, int Z, const char * connectname,
     if (cg->filetype == CGIO_FILE_ADF || cg->filetype == CGIO_FILE_ADF2) {
       if (zconn->id==0) {
         if (cgi_new_node(zone->id, zconn->name, "ZoneGridConnectivity_t",
-			 &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(zconn->id, hid);
       if (hid==0) {
         if (cgi_new_node(zone->id, zconn->name, "ZoneGridConnectivity_t",
-			 &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &zconn->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
 #endif
@@ -6746,7 +7608,7 @@ int cg_boco_id(int file_number, int B, int Z, int BC, double *boco_id)
 }
 
 int cg_boco_gridlocation_read(int file_number, int B, int Z,
-	int BC, CGNS_ENUMT(GridLocation_t) *location)
+    int BC, CGNS_ENUMT(GridLocation_t) *location)
 {
     cgns_boco *boco;
 
@@ -6763,9 +7625,9 @@ int cg_boco_gridlocation_read(int file_number, int B, int Z,
 }
 
 int cg_boco_write(int file_number, int B, int Z, const char * boconame,
-		  CGNS_ENUMT(BCType_t) bocotype,
-		  CGNS_ENUMT(PointSetType_t) ptset_type,
-		  cgsize_t npnts, const cgsize_t * pnts, int *BC)
+          CGNS_ENUMT(BCType_t) bocotype,
+          CGNS_ENUMT(PointSetType_t) ptset_type,
+          cgsize_t npnts, const cgsize_t * pnts, int *BC)
 {
     cgns_zone *zone;
     cgns_zboco *zboco;
@@ -6898,16 +7760,16 @@ int cg_boco_write(int file_number, int B, int Z, const char * boconame,
     if (cg->filetype == CGIO_FILE_ADF || cg->filetype == CGIO_FILE_ADF2) {
       if (zboco->id==0) {
         if (cgi_new_node(zone->id, "ZoneBC", "ZoneBC_t",
-			 &zboco->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &zboco->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(zboco->id, hid);
       if (hid==0) {
         if (cgi_new_node(zone->id, "ZoneBC", "ZoneBC_t",
-			 &zboco->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &zboco->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
 #endif
@@ -6938,7 +7800,7 @@ int cg_boco_write(int file_number, int B, int Z, const char * boconame,
 }
 
 int cg_boco_gridlocation_write(int file_number, int B, int Z,
-	int BC, CGNS_ENUMT(GridLocation_t) location)
+    int BC, CGNS_ENUMT(GridLocation_t) location)
 {
     cgns_boco *boco;
     cgsize_t dim_vals;
@@ -6970,8 +7832,8 @@ int cg_boco_gridlocation_write(int file_number, int B, int Z,
 }
 
 int cg_boco_normal_write(int file_number, int B, int Z, int BC, const int * NormalIndex,
-			 int NormalListFlag, CGNS_ENUMT(DataType_t) NormalDataType,
-			 const void * NormalList)
+             int NormalListFlag, CGNS_ENUMT(DataType_t) NormalDataType,
+             const void * NormalList)
 {
     cgns_boco *boco;
     int n, phys_dim;
@@ -7053,8 +7915,8 @@ int cg_boco_normal_write(int file_number, int B, int Z, int BC, const int * Norm
 \*****************************************************************************/
 
 int cg_dataset_read(int file_number, int B, int Z, int BC, int DSet, char *name,
-		    CGNS_ENUMT(BCType_t) *BCType, int *DirichletFlag,
-		    int *NeumannFlag)
+            CGNS_ENUMT(BCType_t) *BCType, int *DirichletFlag,
+            int *NeumannFlag)
 {
     cgns_dataset *dataset;
 
@@ -7077,7 +7939,7 @@ int cg_dataset_read(int file_number, int B, int Z, int BC, int DSet, char *name,
 }
 
 int cg_dataset_write(int file_number, int B, int Z, int BC, const char * name,
-		     CGNS_ENUMT( BCType_t )  BCType, int *Dset)
+             CGNS_ENUMT( BCType_t )  BCType, int *Dset)
 {
     cgns_boco *boco;
     cgns_dataset *dataset = NULL;
@@ -7150,7 +8012,7 @@ int cg_dataset_write(int file_number, int B, int Z, int BC, const char * name,
 \*****************************************************************************/
 
 int cg_bcdata_write(int file_number, int B, int Z, int BC, int Dset,
-		    CGNS_ENUMT(BCDataType_t) BCDataType)
+            CGNS_ENUMT(BCDataType_t) BCDataType)
 {
     cgns_dataset *dataset;
     cgns_bcdata *bcdata;
@@ -7231,7 +8093,7 @@ int cg_n_rigid_motions(int file_number, int B, int Z, int *n_rigid_motions)
 }
 
 int cg_rigid_motion_read(int file_number, int B, int Z, int R, char *name,
-			 CGNS_ENUMT(RigidGridMotionType_t) *type)
+             CGNS_ENUMT(RigidGridMotionType_t) *type)
 {
 
     cgns_rmotion *rmotion;
@@ -7251,7 +8113,7 @@ int cg_rigid_motion_read(int file_number, int B, int Z, int R, char *name,
 }
 
 int cg_rigid_motion_write(int file_number, int B, int Z, const char * rmotionname,
-			  CGNS_ENUMT(RigidGridMotionType_t) type, int *R)
+              CGNS_ENUMT(RigidGridMotionType_t) type, int *R)
 {
     cgns_zone *zone;
     cgns_rmotion *rmotion = NULL;
@@ -7343,7 +8205,7 @@ int cg_n_arbitrary_motions(int file_number, int B, int Z, int *n_arbitrary_motio
 }
 
 int cg_arbitrary_motion_read(int file_number, int B, int Z, int A, char *name,
-			     CGNS_ENUMT(ArbitraryGridMotionType_t) *type)
+                 CGNS_ENUMT(ArbitraryGridMotionType_t) *type)
 {
 
     cgns_amotion *amotion;
@@ -7363,7 +8225,7 @@ int cg_arbitrary_motion_read(int file_number, int B, int Z, int A, char *name,
 }
 
 int cg_arbitrary_motion_write(int file_number, int B, int Z, const char * amotionname,
-			      CGNS_ENUMT(ArbitraryGridMotionType_t) type, int *A)
+                  CGNS_ENUMT(ArbitraryGridMotionType_t) type, int *A)
 {
     cgns_zone *zone;
     cgns_amotion *amotion = NULL;
@@ -7818,7 +8680,7 @@ int cg_axisym_write(int file_number, int B, float const *ref_point, float const
 \*****************************************************************************/
 
 int cg_bc_wallfunction_read(int file_number, int B, int Z, int BC,
-			    CGNS_ENUMT(WallFunctionType_t) *WallFunctionType)
+                CGNS_ENUMT(WallFunctionType_t) *WallFunctionType)
 {
     cgns_bprop *bprop;
 
@@ -7842,7 +8704,7 @@ int cg_bc_wallfunction_read(int file_number, int B, int Z, int BC,
 }
 
 int cg_bc_wallfunction_write(int file_number, int B, int Z, int BC,
-			     CGNS_ENUMT(WallFunctionType_t) WallFunctionType)
+                 CGNS_ENUMT(WallFunctionType_t) WallFunctionType)
 {
     cgns_bprop *bprop;
     cgns_bcwall *bcwall;
@@ -7901,16 +8763,16 @@ int cg_bc_wallfunction_write(int file_number, int B, int Z, int BC,
     if (cg->filetype == CGIO_FILE_ADF || cg->filetype == CGIO_FILE_ADF2) {
       if (bprop->id==0) {
         if (cgi_new_node(boco->id, "BCProperty", "BCProperty_t",
-			 &bprop->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &bprop->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(bprop->id, hid);
       if (hid==0) {
         if (cgi_new_node(boco->id, "BCProperty", "BCProperty_t",
-			 &bprop->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &bprop->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
 #endif
@@ -7932,8 +8794,8 @@ int cg_bc_wallfunction_write(int file_number, int B, int Z, int BC,
 /*----------------------------------------------------------------------*/
 
 int cg_bc_area_read(int file_number, int B, int Z, int BC,
-		    CGNS_ENUMT(AreaType_t)  *AreaType, float *SurfaceArea,
-		    char *RegionName)
+            CGNS_ENUMT(AreaType_t)  *AreaType, float *SurfaceArea,
+            char *RegionName)
 {
     int n;
     cgns_bprop *bprop;
@@ -7966,8 +8828,8 @@ int cg_bc_area_read(int file_number, int B, int Z, int BC,
 }
 
 int cg_bc_area_write(int file_number, int B, int Z, int BC,
-		     CGNS_ENUMT( AreaType_t )  AreaType, float SurfaceArea,
-		     const char *RegionName)
+             CGNS_ENUMT( AreaType_t )  AreaType, float SurfaceArea,
+             const char *RegionName)
 {
     cgns_boco *boco;
     cgns_bprop *bprop;
@@ -8060,16 +8922,16 @@ int cg_bc_area_write(int file_number, int B, int Z, int BC,
     if (cg->filetype == CGIO_FILE_ADF || cg->filetype == CGIO_FILE_ADF2) {
       if (bprop->id==0) {
         if (cgi_new_node(boco->id, "BCProperty", "BCProperty_t",
-			 &bprop->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &bprop->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(bprop->id, hid);
       if (hid==0) {
         if (cgi_new_node(boco->id, "BCProperty", "BCProperty_t",
-			 &bprop->id, "MT", 0, 0, 0)) return CG_ERROR;
+             &bprop->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
 #endif
@@ -8216,16 +9078,16 @@ int cg_conn_periodic_write(int file_number, int B, int Z, int I,
    if (cg->filetype == CGIO_FILE_ADF || cg->filetype == CGIO_FILE_ADF2) {
      if (cprop->id==0) {
        if (cgi_new_node(conn->id, "GridConnectivityProperty",
-			"GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0)) return CG_ERROR;
+            "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0)) return CG_ERROR;
      }
    }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
    else if (cg->filetype == CGIO_FILE_HDF5) {
      hid_t hid;
      to_HDF_ID(cprop->id, hid);
      if (hid==0) {
        if (cgi_new_node(conn->id, "GridConnectivityProperty",
-			"GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0)) return CG_ERROR;
+            "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0)) return CG_ERROR;
      }
    }
 #endif
@@ -8245,7 +9107,7 @@ int cg_conn_periodic_write(int file_number, int B, int Z, int I,
 /*----------------------------------------------------------------------*/
 
 int cg_conn_average_read(int file_number, int B, int Z, int I,
-			 CGNS_ENUMT(AverageInterfaceType_t) *AverageInterfaceType)
+             CGNS_ENUMT(AverageInterfaceType_t) *AverageInterfaceType)
 {
     cgns_cprop *cprop;
 
@@ -8269,7 +9131,7 @@ int cg_conn_average_read(int file_number, int B, int Z, int I,
 }
 
 int cg_conn_average_write(int file_number, int B, int Z, int I,
-			  CGNS_ENUMT(AverageInterfaceType_t) AverageInterfaceType)
+              CGNS_ENUMT(AverageInterfaceType_t) AverageInterfaceType)
 {
     cgns_cprop *cprop;
     cgns_caverage *caverage;
@@ -8327,16 +9189,16 @@ int cg_conn_average_write(int file_number, int B, int Z, int I,
     if (cg->filetype == CGIO_FILE_ADF || cg->filetype == CGIO_FILE_ADF2) {
       if (cprop->id==0) {
         if (cgi_new_node(conn->id, "GridConnectivityProperty",
-			 "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0)) return CG_ERROR;
+             "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(cprop->id, hid);
       if (hid==0) {
         if (cgi_new_node(conn->id, "GridConnectivityProperty",
-			 "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0)) return CG_ERROR;
+             "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0)) return CG_ERROR;
       }
     }
 #endif
@@ -8402,9 +9264,9 @@ int cg_1to1_periodic_read(int file_number, int B, int Z, int I,
 }
 
 int cg_1to1_periodic_write(int file_number, int B, int Z, int I,
-			   float const *RotationCenter,
-			   float const *RotationAngle,
-			   float const *Translation)
+               float const *RotationCenter,
+               float const *RotationAngle,
+               float const *Translation)
 {
     cgns_base *base;
     cgns_1to1 *one21;
@@ -8480,18 +9342,18 @@ int cg_1to1_periodic_write(int file_number, int B, int Z, int I,
     if (cg->filetype == CGIO_FILE_ADF || cg->filetype == CGIO_FILE_ADF2) {
       if (cprop->id==0) {
         if (cgi_new_node(one21->id, "GridConnectivityProperty",
-			 "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0))
-	  return CG_ERROR;
+             "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0))
+      return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(cprop->id, hid);
       if (hid==0) {
-	if (cgi_new_node(one21->id, "GridConnectivityProperty",
-			 "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0))
-	  return CG_ERROR;
+    if (cgi_new_node(one21->id, "GridConnectivityProperty",
+             "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0))
+      return CG_ERROR;
       }
     }
 #endif
@@ -8511,7 +9373,7 @@ int cg_1to1_periodic_write(int file_number, int B, int Z, int I,
 /*----------------------------------------------------------------------*/
 
 int cg_1to1_average_read(int file_number, int B, int Z, int I,
-			 CGNS_ENUMT(AverageInterfaceType_t) *AverageInterfaceType)
+             CGNS_ENUMT(AverageInterfaceType_t) *AverageInterfaceType)
 {
     cgns_cprop *cprop;
     cgns_1to1 *one21;
@@ -8538,7 +9400,7 @@ int cg_1to1_average_read(int file_number, int B, int Z, int I,
 }
 
 int cg_1to1_average_write(int file_number, int B, int Z, int I,
-			  CGNS_ENUMT(AverageInterfaceType_t) AverageInterfaceType)
+              CGNS_ENUMT(AverageInterfaceType_t) AverageInterfaceType)
 {
     cgns_cprop *cprop;
     cgns_caverage *caverage;
@@ -8598,18 +9460,18 @@ int cg_1to1_average_write(int file_number, int B, int Z, int I,
     if (cg->filetype == CGIO_FILE_ADF || cg->filetype == CGIO_FILE_ADF2) {
       if (cprop->id==0) {
         if (cgi_new_node(one21->id, "GridConnectivityProperty",
-			 "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0))
-	  return CG_ERROR;
+             "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0))
+      return CG_ERROR;
       }
     }
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
     else if (cg->filetype == CGIO_FILE_HDF5) {
       hid_t hid;
       to_HDF_ID(cprop->id, hid);
       if (hid==0) {
-	if (cgi_new_node(one21->id, "GridConnectivityProperty",
-			 "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0))
-	  return CG_ERROR;
+    if (cgi_new_node(one21->id, "GridConnectivityProperty",
+             "GridConnectivityProperty_t", &cprop->id, "MT", 0, 0, 0))
+      return CG_ERROR;
       }
     }
 #endif
@@ -8787,7 +9649,7 @@ int cg_gopath(int file_number, const char *path)
     int n, len;
     const char *p = path, *s;
     int index[CG_MAX_GOTO_DEPTH];
-    char label[CG_MAX_GOTO_DEPTH][33];
+    char label[CG_MAX_GOTO_DEPTH][CGIO_MAX_NAME_LENGTH+1];
     char *lab[CG_MAX_GOTO_DEPTH];
 
     if (p == 0 || !*p) {
@@ -8950,7 +9812,8 @@ int cg_famname_write(const char * family_name)
      /* verify input */
     if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_WRITE)) return CG_ERROR;
 
-    if (cgi_check_strlen(family_name)) return CG_ERROR;
+    /* Family Tree */
+    /*if (cgi_check_strlen(family_name)) return CG_ERROR;*/
 
     famname = cgi_famname_address(CG_MODE_WRITE, &ier);
     if (famname==0) return ier;
@@ -9028,12 +9891,14 @@ int cg_multifam_write(const char *name, const char *family)
     if (cgi_check_strlen(name) ||
         cgi_check_mode(cg->filename, cg->mode, CG_MODE_WRITE)) return CG_ERROR;
 
+/* ** FAMILY TREE ** */
+/*
 #ifdef CG_BUILD_BASESCOPE
     if (cgi_check_strlen_x2(family)) return CG_ERROR;
 #else
     if (cgi_check_strlen(family)) return CG_ERROR;
 #endif
-
+*/
     famname = cgi_multfam_address(CG_MODE_WRITE, 0, name, &ier);
     if (famname == 0) return ier;
 
@@ -9238,7 +10103,7 @@ int cg_equationset_read(int *EquationDimension,
     else            (*TurbulenceModelFlag)=0;
 
     /* Version 2.1 chemistry extensions get their own read routine
-    ** for backward compatability.
+    ** for backward compatibility.
     */
     return CG_OK;
 }
@@ -9267,7 +10132,7 @@ int cg_equationset_chemistry_read(int *ThermalRelaxationFlag,
 }
 
 int cg_equationset_elecmagn_read(int *ElecFldModelFlag, int *MagnFldModelFlag,
-				 int *ConductivityModelFlag)
+                 int *ConductivityModelFlag)
 {
     cgns_equations *eq;
     int ier=0;
@@ -9532,40 +10397,40 @@ int cg_model_write(const char * ModelLabel, CGNS_ENUMT(ModelType_t) ModelType)
      /* Validate enums for each model type. */
     if (strcmp(ModelLabel, "GasModel_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( Ideal ) && ModelType!=CGNS_ENUMV( VanderWaals ) &&
-	  ModelType!=CGNS_ENUMV( CaloricallyPerfect ) && ModelType!=CGNS_ENUMV( ThermallyPerfect ) &&
-	  ModelType!=CGNS_ENUMV( ConstantDensity ) && ModelType!=CGNS_ENUMV( RedlichKwong )) {
+      ModelType!=CGNS_ENUMV( Ideal ) && ModelType!=CGNS_ENUMV( VanderWaals ) &&
+      ModelType!=CGNS_ENUMV( CaloricallyPerfect ) && ModelType!=CGNS_ENUMV( ThermallyPerfect ) &&
+      ModelType!=CGNS_ENUMV( ConstantDensity ) && ModelType!=CGNS_ENUMV( RedlichKwong )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
             return CG_ERROR;
         }
     } else if (strcmp(ModelLabel, "ViscosityModel_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( Constant ) && ModelType!=CGNS_ENUMV( PowerLaw ) && ModelType!=CGNS_ENUMV( SutherlandLaw )) {
+      ModelType!=CGNS_ENUMV( Constant ) && ModelType!=CGNS_ENUMV( PowerLaw ) && ModelType!=CGNS_ENUMV( SutherlandLaw )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
             return CG_ERROR;
         }
     } else if (strcmp(ModelLabel, "ThermalConductivityModel_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( PowerLaw ) && ModelType!=CGNS_ENUMV( SutherlandLaw ) && ModelType!=CGNS_ENUMV( ConstantPrandtl )) {
+      ModelType!=CGNS_ENUMV( PowerLaw ) && ModelType!=CGNS_ENUMV( SutherlandLaw ) && ModelType!=CGNS_ENUMV( ConstantPrandtl )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
             return CG_ERROR;
         }
     } else if (strcmp(ModelLabel, "TurbulenceModel_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( Algebraic_BaldwinLomax )&& ModelType!=CGNS_ENUMV( Algebraic_CebeciSmith )&&
-	  ModelType!=CGNS_ENUMV( HalfEquation_JohnsonKing )&& ModelType!=CGNS_ENUMV( OneEquation_BaldwinBarth )&&
-	  ModelType!=CGNS_ENUMV( OneEquation_SpalartAllmaras )&& ModelType!=CGNS_ENUMV( TwoEquation_JonesLaunder )&&
-	  ModelType!=CGNS_ENUMV( TwoEquation_MenterSST )&& ModelType!=CGNS_ENUMV( TwoEquation_Wilcox )) {
+      ModelType!=CGNS_ENUMV( Algebraic_BaldwinLomax )&& ModelType!=CGNS_ENUMV( Algebraic_CebeciSmith )&&
+      ModelType!=CGNS_ENUMV( HalfEquation_JohnsonKing )&& ModelType!=CGNS_ENUMV( OneEquation_BaldwinBarth )&&
+      ModelType!=CGNS_ENUMV( OneEquation_SpalartAllmaras )&& ModelType!=CGNS_ENUMV( TwoEquation_JonesLaunder )&&
+      ModelType!=CGNS_ENUMV( TwoEquation_MenterSST )&& ModelType!=CGNS_ENUMV( TwoEquation_Wilcox )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
             return CG_ERROR;
         }
     } else if (strcmp(ModelLabel, "TurbulenceClosure_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( EddyViscosity )  && ModelType!=CGNS_ENUMV( ReynoldsStress ) &&
+      ModelType!=CGNS_ENUMV( EddyViscosity )  && ModelType!=CGNS_ENUMV( ReynoldsStress ) &&
             ModelType!=CGNS_ENUMV( ReynoldsStressAlgebraic )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
@@ -9573,16 +10438,16 @@ int cg_model_write(const char * ModelLabel, CGNS_ENUMT(ModelType_t) ModelType)
         }
     } else if (strcmp(ModelLabel, "ThermalRelaxationModel_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( ThermalEquilib ) &&
-	  ModelType!=CGNS_ENUMV( ThermalNonequilib )) {
+      ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( ThermalEquilib ) &&
+      ModelType!=CGNS_ENUMV( ThermalNonequilib )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
             return CG_ERROR;
         }
     } else if (strcmp(ModelLabel, "ChemicalKineticsModel_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( ChemicalEquilibCurveFit ) &&
-	  ModelType!=CGNS_ENUMV( ChemicalEquilibMinimization ) && ModelType!=CGNS_ENUMV( ChemicalNonequilib )) {
+      ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( ChemicalEquilibCurveFit ) &&
+      ModelType!=CGNS_ENUMV( ChemicalEquilibMinimization ) && ModelType!=CGNS_ENUMV( ChemicalNonequilib )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
             return CG_ERROR;
@@ -9590,8 +10455,8 @@ int cg_model_write(const char * ModelLabel, CGNS_ENUMT(ModelType_t) ModelType)
     }
     else if (strcmp(ModelLabel, "EMElectricFieldModel_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( Voltage ) &&
-	  ModelType!=CGNS_ENUMV( Interpolated ) && ModelType!=CGNS_ENUMV( Constant )) {
+      ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( Voltage ) &&
+      ModelType!=CGNS_ENUMV( Interpolated ) && ModelType!=CGNS_ENUMV( Constant )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
             return CG_ERROR;
@@ -9599,8 +10464,8 @@ int cg_model_write(const char * ModelLabel, CGNS_ENUMT(ModelType_t) ModelType)
     }
     else if (strcmp(ModelLabel, "EMMagneticFieldModel_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( Interpolated ) &&
-	  ModelType!=CGNS_ENUMV( Constant )) {
+      ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( Interpolated ) &&
+      ModelType!=CGNS_ENUMV( Constant )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
             return CG_ERROR;
@@ -9608,9 +10473,9 @@ int cg_model_write(const char * ModelLabel, CGNS_ENUMT(ModelType_t) ModelType)
     }
     else if (strcmp(ModelLabel, "EMConductivityModel_t")==0) {
       if (ModelType!=CGNS_ENUMV( ModelTypeNull ) && ModelType!=CGNS_ENUMV( ModelTypeUserDefined ) &&
-	  ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( Constant ) &&
-	  ModelType!=CGNS_ENUMV( Equilibrium_LinRessler ) &&
-	  ModelType!=CGNS_ENUMV( Chemistry_LinRessler )) {
+      ModelType!=CGNS_ENUMV( Frozen ) && ModelType!=CGNS_ENUMV( Constant ) &&
+      ModelType!=CGNS_ENUMV( Equilibrium_LinRessler ) &&
+      ModelType!=CGNS_ENUMV( Chemistry_LinRessler )) {
             cgi_error("Model Type '%s' is not supported for %s",
                 ModelTypeName[ModelType],ModelLabel);
             return CG_ERROR;
@@ -9623,9 +10488,9 @@ int cg_model_write(const char * ModelLabel, CGNS_ENUMT(ModelType_t) ModelType)
         strcmp(ModelLabel, "TurbulenceModel_t") &&
         strcmp(ModelLabel, "ThermalConductivityModel_t") &&
         strcmp(ModelLabel, "ViscosityModel_t") &&
-	strcmp(ModelLabel, "EMElectricFieldModel_t") &&
-	strcmp(ModelLabel, "EMMagneticFieldModel_t") &&
-	strcmp(ModelLabel, "EMConductivityModel_t") &&
+    strcmp(ModelLabel, "EMElectricFieldModel_t") &&
+    strcmp(ModelLabel, "EMMagneticFieldModel_t") &&
+    strcmp(ModelLabel, "EMConductivityModel_t") &&
         strcmp(ModelLabel, "GasModel_t")) {
         cgi_error("Invalid Model Label: %s",ModelLabel);
         return CG_ERROR;
@@ -9735,9 +10600,9 @@ int cg_narrays(int *narrays)
         strcmp(posit->label,"TurbulenceClosure_t")==0 ||
         strcmp(posit->label,"ThermalRelaxationModel_t")==0 ||
         strcmp(posit->label,"ChemicalKineticsModel_t")==0 ||
-	strcmp(posit->label,"EMElectricFieldModel_t")==0 ||
-	strcmp(posit->label,"EMMagneticFieldModel_t")==0 ||
-	strcmp(posit->label,"EMConductivityModel_t")==0) {
+        strcmp(posit->label,"EMElectricFieldModel_t")==0 ||
+        strcmp(posit->label,"EMMagneticFieldModel_t")==0 ||
+        strcmp(posit->label,"EMConductivityModel_t")==0) {
         cgns_model *model = (cgns_model *)posit->posit;
         (*narrays) = model->narrays;
 
@@ -9848,8 +10713,8 @@ int cg_array_read(int A, void *Data)
     if (array->data)
         memcpy(Data, array->data, (size_t)(num*size_of(array->data_type)));
     else {
-        if (cgio_read_all_data(cg->cgio, array->id, Data)) {
-            cg_io_error("cgio_read_all_data");
+        if (cgio_read_all_data_type(cg->cgio, array->id, array->data_type, Data)) {
+            cg_io_error("cgio_read_all_data_type");
             return CG_ERROR;
         }
     }
@@ -9887,8 +10752,8 @@ int cg_array_read_as(int A, CGNS_ENUMT(DataType_t) type, void *Data)
         if (array->data)
             memcpy(Data, array->data, (size_t)(num*size_of(array->data_type)));
         else {
-            if (cgio_read_all_data(cg->cgio, array->id, Data)) {
-                cg_io_error("cgio_read_all_data");
+            if (cgio_read_all_data_type(cg->cgio, array->id, array->data_type, Data)) {
+                cg_io_error("cgio_read_all_data_type");
                 return CG_ERROR;
             }
         }
@@ -9904,8 +10769,8 @@ int cg_array_read_as(int A, CGNS_ENUMT(DataType_t) type, void *Data)
             cgi_error("Error allocating array_data");
             return CG_ERROR;
         }
-        if (cgio_read_all_data(cg->cgio, array->id, array_data)) {
-            cg_io_error("cgio_read_all_data");
+        if (cgio_read_all_data_type(cg->cgio, array->id, array->data_type, array_data)) {
+            cg_io_error("cgio_read_all_data_type");
             return CG_ERROR;
         }
     }
@@ -9965,6 +10830,8 @@ int cg_array_write(const char * ArrayName, CGNS_ENUMT(DataType_t) DataType,
     int n, ier=0;
     double posit_id;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
     CHECK_FILE_OPEN
 
      /* verify input */
@@ -10014,7 +10881,7 @@ int cg_array_write(const char * ArrayName, CGNS_ENUMT(DataType_t) DataType,
     if (cgi_posit_id(&posit_id)) return CG_ERROR;
     if (cgi_new_node(posit_id, array->name, "DataArray_t", &array->id,
         array->data_type, array->data_dim, array->dim_vals, Data)) return CG_ERROR;
-
+    HDF5storage_type = CG_COMPACT;
     return CG_OK;
 }
 
@@ -10048,7 +10915,7 @@ int cg_array_general_write(const char *arrayname,
         return CG_ERROR;
     }
 
-     /*** verfication for dataset in file */
+     /*** verification for dataset in file */
      /* verify the rank and dimensions of the file-space array */
     if (s_numdim <= 0 || s_numdim > CGIO_MAX_DIMENSIONS) {
         cgi_error("Data arrays are limited to %d dimensions in file",
@@ -10219,7 +11086,7 @@ int cg_rind_write(const int * RindData)
         planes are still written but an error is returned */
     ier = cg_narrays(&narrays);
     if (ier == CG_OK && narrays > 0) {
-        cgi_error("Writing rind planes invalidates dimensions of exisitng "
+        cgi_error("Writing rind planes invalidates dimensions of existing "
                   "array(s).");
         return CG_ERROR;
     }
@@ -10301,9 +11168,9 @@ int cg_ndescriptors(int *ndescriptors)
          strcmp(posit->label,"TurbulenceClosure_t")==0 ||
          strcmp(posit->label,"ThermalRelaxationModel_t")==0 ||
          strcmp(posit->label,"ChemicalKineticsModel_t")==0 ||
-	 strcmp(posit->label,"EMElectricFieldModel_t")==0 ||
-	 strcmp(posit->label,"EMMagneticFieldModel_t")==0 ||
-	 strcmp(posit->label,"EMConductivityModel_t")==0)
+     strcmp(posit->label,"EMElectricFieldModel_t")==0 ||
+     strcmp(posit->label,"EMMagneticFieldModel_t")==0 ||
+     strcmp(posit->label,"EMConductivityModel_t")==0)
         NDESCRIPTOR(cgns_model)
     else if (strcmp(posit->label,"ConvergenceHistory_t")==0)
         NDESCRIPTOR(cgns_converg)
@@ -10457,8 +11324,8 @@ int cg_units_read(CGNS_ENUMT(MassUnits_t) *mass,
 int cg_units_write(CGNS_ENUMT(MassUnits_t) mass,
                    CGNS_ENUMT(LengthUnits_t) length,
                    CGNS_ENUMT(TimeUnits_t) time,
-		   CGNS_ENUMT(TemperatureUnits_t) temperature,
-		   CGNS_ENUMT(AngleUnits_t) angle)
+           CGNS_ENUMT(TemperatureUnits_t) temperature,
+           CGNS_ENUMT(AngleUnits_t) angle)
 {
     int ier=0;
     cgns_units *units;
@@ -10514,12 +11381,12 @@ int cg_units_write(CGNS_ENUMT(MassUnits_t) mass,
 
 int cg_unitsfull_read(CGNS_ENUMT(MassUnits_t) *mass,
                       CGNS_ENUMT(LengthUnits_t) *length,
-		      CGNS_ENUMT(TimeUnits_t) *time,
-		      CGNS_ENUMT(TemperatureUnits_t) *temperature,
-		      CGNS_ENUMT(AngleUnits_t) *angle,
-		      CGNS_ENUMT(ElectricCurrentUnits_t) *current,
-		      CGNS_ENUMT(SubstanceAmountUnits_t) *amount,
-		      CGNS_ENUMT(LuminousIntensityUnits_t) *intensity)
+              CGNS_ENUMT(TimeUnits_t) *time,
+              CGNS_ENUMT(TemperatureUnits_t) *temperature,
+              CGNS_ENUMT(AngleUnits_t) *angle,
+              CGNS_ENUMT(ElectricCurrentUnits_t) *current,
+              CGNS_ENUMT(SubstanceAmountUnits_t) *amount,
+              CGNS_ENUMT(LuminousIntensityUnits_t) *intensity)
 {
     cgns_units *units;
     int ier=0;
@@ -10545,12 +11412,12 @@ int cg_unitsfull_read(CGNS_ENUMT(MassUnits_t) *mass,
 
 int cg_unitsfull_write(CGNS_ENUMT(MassUnits_t) mass,
                        CGNS_ENUMT(LengthUnits_t) length,
-		       CGNS_ENUMT(TimeUnits_t) time,
-		       CGNS_ENUMT(TemperatureUnits_t) temperature,
-		       CGNS_ENUMT(AngleUnits_t) angle,
-		       CGNS_ENUMT(ElectricCurrentUnits_t) current,
-		       CGNS_ENUMT(SubstanceAmountUnits_t) amount,
-		       CGNS_ENUMT(LuminousIntensityUnits_t) intensity)
+               CGNS_ENUMT(TimeUnits_t) time,
+               CGNS_ENUMT(TemperatureUnits_t) temperature,
+               CGNS_ENUMT(AngleUnits_t) angle,
+               CGNS_ENUMT(ElectricCurrentUnits_t) current,
+               CGNS_ENUMT(SubstanceAmountUnits_t) amount,
+               CGNS_ENUMT(LuminousIntensityUnits_t) intensity)
 {
     int ier=0;
     cgns_units *units;
@@ -10750,7 +11617,7 @@ int cg_expfull_read(void *exponents)
     /* don't fail - just return 0's for last 3
     if(exponent->nexps != 8)
     {
-	cgi_error("Full set of exponents not written, use cg_exponents_read.");
+    cgi_error("Full set of exponents not written, use cg_exponents_read.");
         return CG_ERROR;
     }*/
 
@@ -10890,7 +11757,7 @@ int cg_conversion_read(void *ConversionFactors)
 }
 
 int cg_conversion_write(CGNS_ENUMT(DataType_t) DataType,
-			const void * ConversionFactors)
+            const void * ConversionFactors)
 {
     cgns_conversion *conversion;
     int ier=0;
@@ -11049,9 +11916,9 @@ int cg_gridlocation_write(CGNS_ENUMT(GridLocation_t) GridLocation)
       if (GridLocation != CGNS_ENUMV(Vertex) &&
           GridLocation != CGNS_ENUMV(CellCenter) &&
           GridLocation != CGNS_ENUMV(FaceCenter) &&
-	  GridLocation != CGNS_ENUMV(IFaceCenter) &&
-	  GridLocation != CGNS_ENUMV(JFaceCenter) &&
-	  GridLocation != CGNS_ENUMV(KFaceCenter)) ier = 1;
+      GridLocation != CGNS_ENUMV(IFaceCenter) &&
+      GridLocation != CGNS_ENUMV(JFaceCenter) &&
+      GridLocation != CGNS_ENUMV(KFaceCenter)) ier = 1;
     }
     else if (strcmp(posit->label,"OversetHoles_t")==0) {
       if (GridLocation != CGNS_ENUMV(Vertex) &&
@@ -11310,9 +12177,9 @@ int cg_nuser_data(int *nuser_data)
         strcmp(posit->label,"TurbulenceClosure_t")==0 ||
         strcmp(posit->label,"ThermalRelaxationModel_t")==0 ||
         strcmp(posit->label,"ChemicalKineticsModel_t")==0 ||
-	 strcmp(posit->label,"EMElectricFieldModel_t")==0 ||
-	 strcmp(posit->label,"EMMagneticFieldModel_t")==0 ||
-	 strcmp(posit->label,"EMConductivityModel_t")==0) )
+     strcmp(posit->label,"EMElectricFieldModel_t")==0 ||
+     strcmp(posit->label,"EMMagneticFieldModel_t")==0 ||
+     strcmp(posit->label,"EMConductivityModel_t")==0) )
         (*nuser_data) = ((cgns_model *)posit->posit)->nuser_data;
     else if (strcmp(posit->label,"GoverningEquations_t")==0)
         (*nuser_data) = ((cgns_governing *)posit->posit)->nuser_data;
@@ -11546,11 +12413,11 @@ int cg_ptset_info(CGNS_ENUMT(PointSetType_t) *ptset_type, cgsize_t *npnts)
     CHECK_FILE_OPEN
 
     if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_READ))
-	return CG_ERROR;
+    return CG_ERROR;
 
     ptset = cgi_ptset_address(CG_MODE_READ, &ier);
     if (ptset == 0)
-	return ier;
+    return ier;
 
     *ptset_type = ptset->type;
     *npnts = ptset->npts;
@@ -11586,7 +12453,7 @@ int cg_ptset_read(cgsize_t *pnts)
 }
 
 int cg_ptset_write(CGNS_ENUMT(PointSetType_t) ptset_type, cgsize_t npnts,
-		   const cgsize_t * pnts)
+           const cgsize_t * pnts)
 {
     cgns_ptset *ptset = 0;
     int i, index_dim;
@@ -11596,7 +12463,7 @@ int cg_ptset_write(CGNS_ENUMT(PointSetType_t) ptset_type, cgsize_t npnts,
 
      /* verify input */
     if(npnts == 0 || pnts == NULL) {
-	cgi_error("Invalid input:  npoint=%d, point set type=%s",
+    cgi_error("Invalid input:  npoint=%d, point set type=%s",
                    npnts, PointSetTypeName[ptset_type]);
         return CG_ERROR;
     }
@@ -11627,24 +12494,24 @@ int cg_ptset_write(CGNS_ENUMT(PointSetType_t) ptset_type, cgsize_t npnts,
 
     /* verify input */
     if (cgi_check_mode(cg->filename, cg->mode, CG_MODE_WRITE))
-	return CG_ERROR;
+    return CG_ERROR;
 
     ptset = cgi_ptset_address(CG_MODE_WRITE, &ier);
     if (ptset==0)
-	return ier;
+    return ier;
 
     /* set these with the provided argument data */
     ptset->type = ptset_type;
     ptset->npts = npnts;
 
     if (ptset_type == CGNS_ENUMV(PointList)) {
-	ptset->size_of_patch = npnts;
+    ptset->size_of_patch = npnts;
     }
     else {
-	ptset->size_of_patch = 1;
-	for (i=0; i < index_dim; i++)
-	    ptset->size_of_patch = ptset->size_of_patch *
-		(pnts[i+index_dim] - pnts[i]+1);
+    ptset->size_of_patch = 1;
+    for (i=0; i < index_dim; i++)
+        ptset->size_of_patch = ptset->size_of_patch *
+        (pnts[i+index_dim] - pnts[i]+1);
     }
 
     /* initialize the following to default values */
@@ -11655,15 +12522,15 @@ int cg_ptset_write(CGNS_ENUMT(PointSetType_t) ptset_type, cgsize_t npnts,
 
      /* Save Point-Set on Disk */
     if (ptset->npts > 0) {
-	double posit_id;
+    double posit_id;
 
-	/* write to disk */
-	if (cgi_posit_id(&posit_id))
-	    return CG_ERROR;
+    /* write to disk */
+    if (cgi_posit_id(&posit_id))
+        return CG_ERROR;
 
-	if (cgi_write_ptset(posit_id, ptset->name, ptset, index_dim,
-			    (void *)pnts))
-	    return CG_ERROR;
+    if (cgi_write_ptset(posit_id, ptset->name, ptset, index_dim,
+                (void *)pnts))
+        return CG_ERROR;
     }
 
     return CG_OK;
@@ -11684,10 +12551,10 @@ int cg_bcdataset_info(int *n_dataset)
         return CG_ERROR;
     }
     if(strcmp(posit->label,"FamilyBC_t") ==0) {
-	cgns_fambc *fambc = (cgns_fambc *)posit->posit;
-	*n_dataset = fambc->ndataset;
+    cgns_fambc *fambc = (cgns_fambc *)posit->posit;
+    *n_dataset = fambc->ndataset;
     } else {
-	*n_dataset = 0;
+    *n_dataset = 0;
         cgi_error("FamilyBC_t node not supported under '%s' type node",
             posit->label);
         return CG_INCORRECT_PATH;
@@ -11697,7 +12564,7 @@ int cg_bcdataset_info(int *n_dataset)
 }
 
 int cg_bcdataset_read(int index, char *name, CGNS_ENUMT(BCType_t) *BCType,
-		      int *DirichletFlag, int *NeumannFlag)
+              int *DirichletFlag, int *NeumannFlag)
 {
     cgns_dataset *dataset;
     int ier = 0;
@@ -11765,9 +12632,9 @@ int cg_bcdataset_write(const char *name, CGNS_ENUMT(BCType_t) BCType,
     }
 
     if (dataset != NULL) {
-	/* Overwrite a BCDataSet_t node : */
+    /* Overwrite a BCDataSet_t node : */
         if (dataset->dirichlet && BCDataType == CGNS_ENUMV(Dirichlet)) {
-	    if (cg->mode == CG_MODE_WRITE) {
+        if (cg->mode == CG_MODE_WRITE) {
                 cgi_error("Dirichlet data already defined under FamilyBCDataSet_t '%s'",
                     dataset->name);
                 return CG_ERROR;
@@ -11775,61 +12642,61 @@ int cg_bcdataset_write(const char *name, CGNS_ENUMT(BCType_t) BCType,
             if (cgi_delete_node(dataset->id, dataset->dirichlet->id))
                 return CG_ERROR;
             cgi_free_bcdata(dataset->dirichlet);
-	    dataset->dirichlet = NULL;
-	}
-        else if (dataset->neumann && BCDataType == CGNS_ENUMV(Neumann))	{
-	    if (cg->mode == CG_MODE_WRITE) {
-		cgi_error("Neumann data already defined under FamilyBCDataSet_t '%s'",
-			  dataset->name);
-		return CG_ERROR;
-	    }
+        dataset->dirichlet = NULL;
+    }
+        else if (dataset->neumann && BCDataType == CGNS_ENUMV(Neumann))    {
+        if (cg->mode == CG_MODE_WRITE) {
+        cgi_error("Neumann data already defined under FamilyBCDataSet_t '%s'",
+              dataset->name);
+        return CG_ERROR;
+        }
             if (cgi_delete_node(dataset->id, dataset->neumann->id))
-	        return CG_ERROR;
-	    cgi_free_bcdata(dataset->neumann);
-	    dataset->neumann = NULL;
-	}
+            return CG_ERROR;
+        cgi_free_bcdata(dataset->neumann);
+        dataset->neumann = NULL;
+    }
+    } else {
+    /* get memory address for FamilyBCDataSet_t node */
+    dataset = cgi_bcdataset_address(CG_MODE_WRITE, 0, name, &ierr);
+    if (dataset == 0) return ierr;
+
+    /* save data in memory */
+    memset(dataset, 0, sizeof(cgns_dataset));
+    dataset->type = BCType;
+    strcpy(dataset->name, name);
+
+    /* write to disk */
+    if (cgi_posit_id(&posit_id)) return CG_ERROR;
+
+    /* save data in file */
+    length = (cgsize_t)strlen(BCTypeName[dataset->type]);
+    if (cg->filetype == CG_FILE_ADF2) {
+        if (cgi_new_node(posit_id, dataset->name, "BCDataSet_t",
+                &dataset->id, "C1", 1, &length,
+                (void *)BCTypeName[dataset->type]))
+            return CG_ERROR;
     } else {
-	/* get memory address for FamilyBCDataSet_t node */
-	dataset = cgi_bcdataset_address(CG_MODE_WRITE, 0, name, &ierr);
-	if (dataset == 0) return ierr;
-
-	/* save data in memory */
-	memset(dataset, 0, sizeof(cgns_dataset));
-	dataset->type = BCType;
-	strcpy(dataset->name, name);
-
-	/* write to disk */
-	if (cgi_posit_id(&posit_id)) return CG_ERROR;
-
-	/* save data in file */
-	length = (cgsize_t)strlen(BCTypeName[dataset->type]);
-	if (cg->filetype == CG_FILE_ADF2) {
-	    if (cgi_new_node(posit_id, dataset->name, "BCDataSet_t",
-	            &dataset->id, "C1", 1, &length,
-	            (void *)BCTypeName[dataset->type]))
-	        return CG_ERROR;
-	} else {
-	    if (cgi_new_node(posit_id, dataset->name, "FamilyBCDataSet_t",
-	            &dataset->id, "C1", 1, &length,
-	            (void *)BCTypeName[dataset->type]))
-	        return CG_ERROR;
-	}
+        if (cgi_new_node(posit_id, dataset->name, "FamilyBCDataSet_t",
+                &dataset->id, "C1", 1, &length,
+                (void *)BCTypeName[dataset->type]))
+            return CG_ERROR;
+    }
     }
 
     if (BCDataType == CGNS_ENUMV(Dirichlet)) {
         if ( !dataset->dirichlet)
-	    dataset->dirichlet = CGNS_NEW(cgns_bcdata,1);
+        dataset->dirichlet = CGNS_NEW(cgns_bcdata,1);
         strcpy(dataset->dirichlet->name, "DirichletData");
         bcdata = dataset->dirichlet;
     } else if(BCDataType == CGNS_ENUMV(Neumann)){
         if ( !dataset->neumann)
-	    dataset->neumann = CGNS_NEW(cgns_bcdata,1);
+        dataset->neumann = CGNS_NEW(cgns_bcdata,1);
         strcpy(dataset->neumann->name, "NeumannData");
         bcdata = dataset->neumann;
     }
     else {
         cgi_error("BCDataType is not Dirichlet or Neumann");
-	return CG_ERROR;
+    return CG_ERROR;
     }
 
     if (cgi_new_node(dataset->id, bcdata->name, "BCData_t", &bcdata->id,
@@ -12080,7 +12947,7 @@ int cg_delete_node(const char *node_name)
     if (strcmp(posit->label,"CGNSBase_t")==0) {
         cgns_base *parent = (cgns_base *)posit->posit;
 
-     /* Case 1: node_label = can have multiple occurence:  */
+     /* Case 1: node_label = can have multiple occurrence:  */
         if (strcmp(node_label,"Zone_t")==0)
             CGNS_DELETE_SHIFT(nzones, zone, cgi_free_zone)
         else if (strcmp(node_label,"Family_t")==0)
@@ -12094,7 +12961,7 @@ int cg_delete_node(const char *node_name)
 
      /* Case 2: node_label = can only occur once under parent: */
         else if (strcmp(node_name,"SimulationType")==0) {
-	    parent->type = CGNS_ENUMV( SimulationTypeNull );
+        parent->type = CGNS_ENUMV( SimulationTypeNull );
             parent->type_id = 0;
         }
         else if (strcmp(node_label,"BaseIterativeData_t")==0)
@@ -12108,7 +12975,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_name,"ReferenceState")==0)
             CGNS_DELETE_CHILD(state, cgi_free_state)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"Gravity")==0)
             CGNS_DELETE_CHILD(gravity, cgi_free_gravity)
         else if (strcmp(node_name,"Axisymmetry")==0)
@@ -12152,7 +13019,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_name,"ReferenceState")==0)
             CGNS_DELETE_CHILD(state, cgi_free_state)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"FamilyName")==0)
             parent->family_name[0]='\0';
         else if (strcmp(node_name,"DimensionalUnits")==0)
@@ -12177,13 +13044,13 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"AdditionalFamilyName_t")==0)
             CGNS_DELETE_SHIFT(nfamname, famname, cgi_free_famname)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"FamilyName")==0)
             parent->family_name[0]='\0';
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         else if (strcmp(node_name,"GridLocation")==0)
-	  parent->location=CGNS_ENUMV( GridLocationNull );
+      parent->location=CGNS_ENUMV( GridLocationNull );
         else if (strcmp(node_name,"Rind")==0) {
             if (posit_base && posit_zone) {
                 index_dim = cg->base[posit_base-1].zone[posit_zone-1].index_dim;
@@ -12213,7 +13080,7 @@ int cg_delete_node(const char *node_name)
             for (n=0; n<2*index_dim; n++) parent->rind_planes[n] = 0;
         }
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12223,7 +13090,7 @@ int cg_delete_node(const char *node_name)
         if (strcmp(node_label,"Descriptor_t")==0)
             CGNS_DELETE_SHIFT(ndescr, descr, cgi_free_descr)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalExponents")==0)
             CGNS_DELETE_CHILD(exponents, cgi_free_exponents)
         else if (strcmp(node_name,"DataConversion")==0)
@@ -12244,11 +13111,11 @@ int cg_delete_node(const char *node_name)
                  strcmp(node_name,"PointRange")==0)
             CGNS_DELETE_CHILD(ptset, cgi_free_ptset)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         else if (strcmp(node_name,"GridLocation")==0)
-	  parent->location=CGNS_ENUMV( GridLocationNull );
+      parent->location=CGNS_ENUMV( GridLocationNull );
         else if (strcmp(node_name,"Rind")==0) {
             if (posit_base && posit_zone) {
                 index_dim = cg->base[posit_base-1].zone[posit_zone-1].index_dim;
@@ -12281,7 +13148,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"UserDefinedData_t")==0)
             CGNS_DELETE_SHIFT(nuser_data, user_data, cgi_free_user_data)
         else if (strcmp(node_name,"GridLocation")==0)
-	  parent->location=CGNS_ENUMV( GridLocationNull );
+      parent->location=CGNS_ENUMV( GridLocationNull );
      /* IndexRange_t & IndexArray_t can't be deleted */
 
 /* Children of GridConnectivity_t */
@@ -12292,7 +13159,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"UserDefinedData_t")==0)
             CGNS_DELETE_SHIFT(nuser_data, user_data, cgi_free_user_data)
         else if (strcmp(node_name,"InterpolantsDonor")==0) {
-	  if (parent->dptset.type==CGNS_ENUMV( CellListDonor )) {
+      if (parent->dptset.type==CGNS_ENUMV( CellListDonor )) {
                 cgi_error("Node '%s' under '%s' can not be deleted",
                     node_name,posit->label);
                 return CG_ERROR;
@@ -12301,11 +13168,11 @@ int cg_delete_node(const char *node_name)
             }
         }
         else if (strcmp(node_name,"GridLocation")==0)
-	  parent->location=CGNS_ENUMV( GridLocationNull );
+      parent->location=CGNS_ENUMV( GridLocationNull );
         else if (strcmp(node_name,"Ordinal")==0)
             parent->ordinal=0;
         else if (strcmp(node_name,"GridConnectivityType")==0)
-	  parent->type=CGNS_ENUMV( GridConnectivityTypeNull );
+      parent->type=CGNS_ENUMV( GridConnectivityTypeNull );
         else if (strcmp(node_name,"GridConnectivityProperty")==0)
             CGNS_DELETE_CHILD(cprop, cgi_free_cprop)
      /* IndexArray_t & IndexRange_t can't be deleted */
@@ -12333,7 +13200,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"BC_t")==0)
             CGNS_DELETE_SHIFT(nbocos, boco, cgi_free_boco)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         else if (strcmp(node_name,"ReferenceState")==0)
@@ -12370,11 +13237,11 @@ int cg_delete_node(const char *node_name)
  #endif
         }
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         else if (strcmp(node_name,"GridLocation")==0)
-	  parent->location=CGNS_ENUMV( GridLocationNull );
+      parent->location=CGNS_ENUMV( GridLocationNull );
         else if (strcmp(node_name,"InwardNormalIndex")==0) {
             if (parent->Nindex) free(parent->Nindex);
             parent->Nindex=0;
@@ -12400,7 +13267,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"UserDefinedData_t")==0)
             CGNS_DELETE_SHIFT(nuser_data, user_data, cgi_free_user_data)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"PointList")==0 ||
                  strcmp(node_name,"PointRange")==0)
             CGNS_DELETE_CHILD(ptset, cgi_free_ptset)
@@ -12412,9 +13279,9 @@ int cg_delete_node(const char *node_name)
             CGNS_DELETE_CHILD(neumann, cgi_free_bcdata)
         else if (strcmp(node_name,"ReferenceState")==0)
             CGNS_DELETE_CHILD(state, cgi_free_state)
-	else if (strcmp(node_name,"GridLocation")==0)
-	  parent->location=CGNS_ENUMV( GridLocationNull );
-	/* IndexRange_t PointRange & IndexArray_t PointList can't be deleted */
+    else if (strcmp(node_name,"GridLocation")==0)
+      parent->location=CGNS_ENUMV( GridLocationNull );
+    /* IndexRange_t PointRange & IndexArray_t PointList can't be deleted */
 
 /* Children of BCData_t */
     } else if (strcmp(posit->label,"BCData_t")==0) {
@@ -12426,7 +13293,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12443,11 +13310,11 @@ int cg_delete_node(const char *node_name)
                  strcmp(node_name,"PointRange")==0)
             CGNS_DELETE_CHILD(ptset, cgi_free_ptset)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         else if (strcmp(node_name,"GridLocation")==0)
-	  parent->location=CGNS_ENUMV( GridLocationNull );
+      parent->location=CGNS_ENUMV( GridLocationNull );
         else if (strcmp(node_name,"Rind")==0) {
             if (posit_base && posit_zone) {
                 index_dim = cg->base[posit_base-1].zone[posit_zone-1].index_dim;
@@ -12466,7 +13333,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"UserDefinedData_t")==0)
             CGNS_DELETE_SHIFT(nuser_data, user_data, cgi_free_user_data)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         else if (strcmp(node_name,"GoverningEquations")==0)
@@ -12481,11 +13348,11 @@ int cg_delete_node(const char *node_name)
             CGNS_DELETE_CHILD(conduct, cgi_free_model)
         else if (strcmp(node_name,"ChemicalKineticsModel")==0)
             CGNS_DELETE_CHILD(chemkin, cgi_free_model)
-	else if (strcmp(node_name,"EMElectricFieldModel")==0)
+    else if (strcmp(node_name,"EMElectricFieldModel")==0)
             CGNS_DELETE_CHILD(elecfield, cgi_free_model)
-	else if (strcmp(node_name,"EMMagneticFieldModel")==0)
+    else if (strcmp(node_name,"EMMagneticFieldModel")==0)
             CGNS_DELETE_CHILD(magnfield, cgi_free_model)
-	else if (strcmp(node_name,"EMConductivityModel")==0)
+    else if (strcmp(node_name,"EMConductivityModel")==0)
             CGNS_DELETE_CHILD(emconduct, cgi_free_model)
         else if (strcmp(node_name,"TurbulenceModel")==0) {
             if (parent->turbulence) {
@@ -12521,9 +13388,9 @@ int cg_delete_node(const char *node_name)
            strcmp(posit->label,"TurbulenceClosure_t")==0 ||
            strcmp(posit->label,"ThermalRelaxationModel_t")==0 ||
            strcmp(posit->label,"ChemicalKineticsModel_t")==0 ||
-	   strcmp(posit->label,"EMElectricFieldModel_t")==0 ||
-	   strcmp(posit->label,"EMMagneticFieldModel_t")==0 ||
-	   strcmp(posit->label,"EMConductivityModel_t")==0) {
+       strcmp(posit->label,"EMElectricFieldModel_t")==0 ||
+       strcmp(posit->label,"EMMagneticFieldModel_t")==0 ||
+       strcmp(posit->label,"EMConductivityModel_t")==0) {
         cgns_model *parent = (cgns_model *)posit->posit;
         if (strcmp(node_label,"Descriptor_t")==0)
             CGNS_DELETE_SHIFT(ndescr, descr, cgi_free_descr)
@@ -12532,7 +13399,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         else if (strcmp(posit->label,"TurbulenceModel_t")==0 &&
@@ -12553,7 +13420,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12567,7 +13434,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12583,7 +13450,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12602,8 +13469,10 @@ int cg_delete_node(const char *node_name)
             CGNS_DELETE_SHIFT(nfamname, famname, cgi_free_famname)
         else if (strcmp(node_name,"Ordinal")==0)
             parent->ordinal=0;
-	else if (strcmp(node_name,"RotatingCoordinates")==0)
+        else if (strcmp(node_name,"RotatingCoordinates")==0)
             CGNS_DELETE_CHILD(rotating, cgi_free_rotating)
+        else if (strcmp(node_label,"Family_t")==0) /* ** FAMILY TREE **/
+            CGNS_DELETE_SHIFT(nfamilies, family, cgi_free_family)
 
 /* Children of FamilyBC_t */
     } else if (strcmp(posit->label,"FamilyBC_t")==0) {
@@ -12659,7 +13528,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12673,11 +13542,11 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         else if (strcmp(node_name,"GridLocation")==0)
-	  parent->location=CGNS_ENUMV( GridLocationNull );
+      parent->location=CGNS_ENUMV( GridLocationNull );
         else if (strcmp(node_name,"Rind")==0) {
             if (posit_base && posit_zone) {
                 index_dim = cg->base[posit_base-1].zone[posit_zone-1].index_dim;
@@ -12698,7 +13567,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12712,7 +13581,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12729,18 +13598,18 @@ int cg_delete_node(const char *node_name)
                  strcmp(node_name,"PointRange")==0)
             CGNS_DELETE_CHILD(ptset, cgi_free_ptset)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         else if (strcmp(node_label,"UserDefinedData_t")==0)
             CGNS_DELETE_SHIFT(nuser_data, user_data, cgi_free_user_data)
-	else if (strcmp(node_name,"GridLocation")==0)
-	  parent->location=CGNS_ENUMV( GridLocationNull );
-	else if (strcmp(node_name,"FamilyName")==0)
-	    parent->family_name[0]='\0';
-	else if (strcmp(node_name,"Ordinal")==0)
-	    parent->ordinal=0;
-	/* IndexRange_t PointRange & IndexArray_t PointList can't be deleted */
+    else if (strcmp(node_name,"GridLocation")==0)
+      parent->location=CGNS_ENUMV( GridLocationNull );
+    else if (strcmp(node_name,"FamilyName")==0)
+        parent->family_name[0]='\0';
+    else if (strcmp(node_name,"Ordinal")==0)
+        parent->ordinal=0;
+    /* IndexRange_t PointRange & IndexArray_t PointList can't be deleted */
 
 /* Children of Gravity_t */
     } else if (strcmp(posit->label,"Gravity_t")==0) {
@@ -12750,7 +13619,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"UserDefinedData_t")==0)
             CGNS_DELETE_SHIFT(nuser_data, user_data, cgi_free_user_data)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12764,7 +13633,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12778,7 +13647,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"DataArray_t")==0)
             CGNS_DELETE_SHIFT(narrays, array, cgi_free_array)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
 
@@ -12832,7 +13701,7 @@ int cg_delete_node(const char *node_name)
         else if (strcmp(node_label,"UserDefinedData_t")==0)
             CGNS_DELETE_SHIFT(nuser_data, user_data, cgi_free_user_data)
         else if (strcmp(node_name,"DataClass")==0)
-	  parent->data_class = CGNS_ENUMV( DataClassNull );
+      parent->data_class = CGNS_ENUMV( DataClassNull );
         else if (strcmp(node_name,"DimensionalUnits")==0)
             CGNS_DELETE_CHILD(units, cgi_free_units)
         /* RotationCenter, RotationAngle and Translation can't be deleted */
diff --git a/src/cgnslib.h b/src/cgnslib.h
index 9e4a54352df..d141ae63c0e 100644
--- a/ThirdParty/cgns/vtkcgns/src/cgnslib.h
+++ b/ThirdParty/cgns/vtkcgns/src/cgnslib.h
@@ -35,8 +35,8 @@
 #ifndef CGNSLIB_H
 #define CGNSLIB_H
 
-#define CGNS_VERSION 4000
-#define CGNS_DOTVERS 4.00
+#define CGNS_VERSION 4100
+#define CGNS_DOTVERS 4.10
 
 #define CGNS_COMPATVERSION 2540
 #define CGNS_COMPATDOTVERS 2.54
@@ -128,8 +128,14 @@
 #define CG_CONFIG_HDF5_COMPRESS   201
 #define CG_CONFIG_HDF5_MPI_COMM   202
 
+/* HDF5 dataset storage layout */
+
+#define CG_CONTIGUOUS 0
+#define CG_COMPACT    1
+#define CG_CHUNKED    2
+
 /* note: CG_CONFIG_RIND_ZERO is obsolete and considered a bug.  Users are given
- *       the option only for backwards compatibilty */
+ *       the option only for backwards compatibility */
 #define CG_CONFIG_RIND_ZERO (void*)0
 #define CG_CONFIG_RIND_CORE (void*)1
 
@@ -345,7 +351,7 @@ typedef enum {
 } CGNS_ENUMT( GoverningEquationsType_t );
 
 /* Any model type will accept both ModelTypeNull and ModelTypeUserDefined.
-** The following models will accept these values as vaild...
+** The following models will accept these values as valid...
 **
 ** GasModel_t: Ideal, VanderWaals, CaloricallyPerfect, ThermallyPerfect,
 **    ConstantDensity, RedlichKwong
@@ -863,6 +869,14 @@ CGNSDLL int cg_family_name_read(int file_number, int B, int F,
 CGNSDLL int cg_family_name_write(int file_number, int B, int F,
 	const char *name, const char *family);
 
+/* FamilyTree extension */ /* ** FAMILY TREE ** */
+CGNSDLL int cg_node_family_write( const char* family_name, int* F);
+CGNSDLL int cg_node_nfamilies( int* nfamilies );
+CGNSDLL int cg_node_family_read( int F, char* family_name, int* nFamBC, int *nGeo );
+CGNSDLL int cg_node_family_name_write( const char* node_name, const char* family_name );
+CGNSDLL int cg_node_nfamily_names( int* nnames );
+CGNSDLL int cg_node_family_name_read(int N, char* node_name, char* family_name );
+  
 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\
  *      Read and write FamilyName_t Nodes                                *
 \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
@@ -879,18 +893,31 @@ CGNSDLL int cg_multifam_write(const char *name, const char *family);
 \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
 
 CGNSDLL int cg_fambc_read(int file_number, int B, int F, int BC,
-	char *fambc_name, CGNS_ENUMT(BCType_t) *bocotype);
+    char *fambc_name, CGNS_ENUMT(BCType_t) *bocotype);
 CGNSDLL int cg_fambc_write(int file_number, int B, int F,
-	const char * fambc_name, CGNS_ENUMT(BCType_t) bocotype, int *BC);
+    const char * fambc_name, CGNS_ENUMT(BCType_t) bocotype, int *BC);
+
+/* FamilyTree extension */ /* ** FAMILY TREE ** */
+
+CGNSDLL int cg_node_fambc_read( int BC, char* fambc_name,
+        CGNS_ENUMT(BCType_t) *bocotype);
+CGNSDLL int cg_node_fambc_write( const char* fambc_name,
+        CGNS_ENUMT(BCType_t) bocotype, int *BC );
 
 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\
  *      Read and write GeometryReference_t Nodes                         *
 \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
 
 CGNSDLL int cg_geo_read(int file_number, int B, int F, int G, char *geo_name,
-	char **geo_file, char *CAD_name, int *npart);
+    char **geo_file, char *CAD_name, int *npart);
 CGNSDLL int cg_geo_write(int file_number, int B, int F, const char * geo_name,
-	const char * filename, const char * CADname, int *G);
+    const char * filename, const char * CADname, int *G);
+
+/* FamilyTree extension */ /* ** FAMILY TREE ** */
+CGNSDLL int cg_node_geo_read( int G, char *geo_name,
+        char **geo_file, char *CAD_name, int *npart );
+CGNSDLL int cg_node_geo_write( const char *geo_name,
+        const char *filename, const char *CADname, int *G);
 
 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\
  *      Read and write GeometryEntity_t Nodes                            *
@@ -901,6 +928,10 @@ CGNSDLL int cg_part_read(int file_number, int B, int F, int G, int P,
 CGNSDLL int cg_part_write(int file_number, int B, int F, int G,
 	const char * part_name, int *P);
 
+/* FamilyTree extension */ /* ** FAMILY TREE ** */
+CGNSDLL int cg_node_part_read(int G, int P, char *part_name);
+CGNSDLL int cg_node_part_write(int G, const char * part_name, int *P);
+
 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\
  *      Read and write GridCoordinates_t Nodes                           *
 \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
@@ -909,6 +940,10 @@ CGNSDLL int cg_ngrids(int file_number, int B, int Z, int *ngrids);
 CGNSDLL int cg_grid_read(int file_number, int B, int Z, int G, char *gridname);
 CGNSDLL int cg_grid_write(int file_number, int B, int Z,
 	const char * zcoorname, int *G);
+CGNSDLL int cg_grid_bounding_box_read(int file_number, int B, int Z, int G,
+        CGNS_ENUMT(DataType_t) type, void* boundingbox);
+CGNSDLL int cg_grid_bounding_box_write(int file_number, int B, int Z, int G,
+        CGNS_ENUMT(DataType_t) type, void* boundingbox);
 
 /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\
  *      Read and write GridCoordinates_t/DataArray_t Nodes               *
diff --git a/src/cgnstypes.h.in b/src/cgnstypes.h.in
index 66a4e295554..9ed9c4c7160 100644
--- a/ThirdParty/cgns/vtkcgns/src/cgnstypes.h.in
+++ b/ThirdParty/cgns/vtkcgns/src/cgnstypes.h.in
@@ -31,10 +31,12 @@
 
 #include "vtk_cgns_mangle.h"
 
+#define CG_BUILD_HDF5   @BUILDHDF5@
 #define CG_BUILD_LEGACY @BUILDLEGACY@
 #define CG_BUILD_64BIT  @BUILD64BIT@
 #define CG_BUILD_SCOPE  @BUILDSCOPE@
 #define CG_BUILD_BASESCOPE @BUILDBASESCOPE@
+#define CG_BUILD_PARALLEL  @BUILDPARALLEL@
 
 #define CG_MAX_INT32 0x7FFFFFFF
 #ifdef _WIN32
@@ -48,7 +50,7 @@
 # define CG_LONG_T @CGLONGT@
 #endif
 
-#ifdef BUILD_HDF5
+#if CG_BUILD_HDF5
 
 /* ----------------------------------------------------------------
  * convert between HDF5 and ADF ids
@@ -65,6 +67,10 @@
 
 #define HDF5_HAVE_COLL_METADATA @HDF5_HAVE_COLL_METADATA@
 
+/* Determine if hdf5 H5Pset_file_space_strategy */
+
+#define HDF5_HAVE_FILE_SPACE_STRATEGY @HDF5_HAVE_FILE_SPACE_STRATEGY@
+
 #endif
 
 #define  CG_HAVE_STAT64_STRUCT @HAVE_STAT64_STRUCT@
diff --git a/src/pcgnslib.c b/src/pcgnslib.c
index 9bd2b371078..7da10ba27d3 100644
--- a/ThirdParty/cgns/vtkcgns/src/pcgnslib.c
+++ b/ThirdParty/cgns/vtkcgns/src/pcgnslib.c
@@ -366,11 +366,22 @@ static int check_parallel(cgns_file *cgfile)
 
 int cgp_mpi_comm(MPI_Comm comm)
 {
-    pcg_mpi_comm=comm;
-    if( cgio_configure(CG_CONFIG_HDF5_MPI_COMM, &comm) != -1) {
-      return CG_ERROR;
+    /* check if we are actually running a parallel program */
+    /* Flag is true if MPI_Init or MPI_Init_thread has been called and false otherwise. */
+    pcg_mpi_initialized = 0;
+    MPI_Initialized(&pcg_mpi_initialized);
+
+    if (pcg_mpi_initialized) {
+      if( cgio_configure(CG_CONFIG_HDF5_MPI_COMM, &comm) != -1) {
+	return CG_ERROR;
+      }
+
+      pcg_mpi_comm=comm;
+      MPI_Comm_rank(pcg_mpi_comm, &pcg_mpi_comm_rank);
+      MPI_Comm_size(pcg_mpi_comm, &pcg_mpi_comm_size);
     }
-    return CG_OK;
+
+    return pcg_mpi_initialized ? CG_OK : CG_ERROR;
 }
 
 int cgp_mpi_info(MPI_Info info)
@@ -415,14 +426,11 @@ int cgp_open(const char *filename, int mode, int *fn)
 {
     int ierr, old_type = cgns_filetype;
 
-
-    MPI_Comm_rank(pcg_mpi_comm, &pcg_mpi_comm_rank);
-    MPI_Comm_size(pcg_mpi_comm, &pcg_mpi_comm_size);
-
-    /* Flag is true if MPI_Init or MPI_Init_thread has been called and false otherwise. */
-    pcg_mpi_initialized = 0;
-    /* check if we are actually running a parallel program */
-    MPI_Initialized(&pcg_mpi_initialized);
+    /* Initialize communicators if cgp_mpi_comm() was not called by
+       client */
+    if (pcg_mpi_comm == MPI_COMM_NULL) {
+      cgp_mpi_comm(MPI_COMM_WORLD);
+    }
 
     /* Flag this as a parallel access */
     strcpy(hdf5_access,"PARALLEL");	
@@ -897,7 +905,7 @@ int cgp_parent_data_write(int fn, int B, int Z, int S,
     cgsize_t num = end == 0 ? 0 : end - start + 1;
     num = num < 0 ? 0 : num;
     MPI_Datatype mpi_type = sizeof(cgsize_t) == 32 ? MPI_INT : MPI_LONG_LONG_INT;
-    MPI_Allreduce(MPI_IN_PLACE, &num, 1, mpi_type, MPI_SUM, MPI_COMM_WORLD);
+    MPI_Allreduce(MPI_IN_PLACE, &num, 1, mpi_type, MPI_SUM, pcg_mpi_comm);
 
     strcpy(section->parelem->data_type, CG_SIZE_DATATYPE);
     section->parelem->data_dim = 2;
diff --git a/src/vtk_cgns_mangle.h b/src/vtk_cgns_mangle.h
index 6db8b40228d..363c40e184e 100644
--- a/ThirdParty/cgns/vtkcgns/src/vtk_cgns_mangle.h
+++ b/ThirdParty/cgns/vtkcgns/src/vtk_cgns_mangle.h
@@ -503,6 +503,7 @@
 #define cgio_read_all_data vtkcgns_cgio_read_all_data
 #define cgio_read_all_data_type vtkcgns_cgio_read_all_data_type
 #define cgio_read_block_data vtkcgns_cgio_read_block_data
+#define cgio_read_block_data_type vtkcgns_cgio_read_block_data_type
 #define cgio_read_data vtkcgns_cgio_read_data
 #define cgio_read_data_type vtkcgns_cgio_read_data_type
 #define cgio_release_id vtkcgns_cgio_release_id
